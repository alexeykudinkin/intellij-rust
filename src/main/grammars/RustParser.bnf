{
    parserClass='org.rust.lang.core.parser.RustParser'
    parserUtilClass='org.rust.lang.core.parser.RustParserUtil'
    psiTreeUtilClass='org.rust.lang.core.parser.RustPsiTreeUtil'

    implements='org.rust.lang.core.psi.RsCompositeElement'
    extends='org.rust.lang.core.psi.impl.RsCompositeElementImpl'

    elementTypeHolderClass='org.rust.lang.core.psi.RsCompositeElementTypes'

    elementTypeClass='org.rust.lang.core.psi.RsCompositeElementType'
    tokenTypeClass='org.rust.lang.core.psi.RsTokenType'

    psiClassPrefix='Rs'
    psiImplClassSuffix='Impl'
    psiPackage='org.rust.lang.core.psi'
    psiImplPackage='org.rust.lang.core.psi.impl'

    parserImports=[
      'static org.rust.lang.core.psi.RsTokenElementTypes.*'
      'static org.rust.lang.core.parser.RustParserUtil.PathParsingMode.*'
      'static org.rust.lang.core.parser.RustParserUtil.BinaryMode.*'
    ]


    tokens = [
        LBRACE               =  '{'
        RBRACE               =  '}'
        LBRACK               =  '['
        RBRACK               =  ']'
        LPAREN               =  '('
        RPAREN               =  ')'
        COLON                =  ':'
        COLONCOLON           =  '::'
        SEMICOLON            =  ';'
        COMMA                =  ','
        EQ                   =  '='
        EXCLEQ               =  '!='
        EQEQ                 =  '=='
        SHA                  =  '#'
        EXCL                 =  '!'
        PLUSEQ               =  '+='
        PLUS                 =  '+'
        MINUSEQ              =  '-='
        MINUS                =  '-'
        OREQ                 =  '|='
        ANDAND               =  '&&'
        ANDEQ                =  '&='
        AND                  =  '&'
        OR                   =  '|'
        LT                   =  '<'
        XOREQ                =  '^='
        XOR                  =  '^'
        MULEQ                =  '*='
        MUL                  =  '*'
        DIVEQ                =  '/='
        DIV                  =  '/'
        REMEQ                =  '%='
        REM                  =  '%'
        GT                   =  '>'
        DOT                  =  '.'
        DOTDOT               =  '..'
        DOTDOTDOT            =  '...'
        FAT_ARROW            =  '=>'
        ARROW                =  '->'
        Q                    =  '?'
        AT                   =  '@'
        UNDERSCORE           =  '_'

        // DEBUG

        ABSTRACT  = 'abstract'
        ALIGNOF   = 'alignof'
        AS        = 'as'
        BECOME    = 'become'
        BOX       = 'box'
        BREAK     = 'break'
        CONST     = 'const'
        CONTINUE  = 'continue'
        CRATE     = 'crate'
        DO        = 'do'
        ELSE      = 'else'
        ENUM      = 'enum'
        EXTERN    = 'extern'
        FALSE     = 'false'
        FINAL     = 'final'
        FN        = 'fn'
        FOR       = 'for'
        IF        = 'if'
        IMPL      = 'impl'
        IN        = 'in'
        LET       = 'let'
        LOOP      = 'loop'
        MACRO     = 'macro'
        MATCH     = 'match'
        MOD       = 'mod'
        MOVE      = 'move'
        MUT       = 'mut'
        OFFSETOF  = 'offsetof'
        OVERRIDE  = 'override'
        PRIV      = 'priv'
        PROC      = 'proc'
        PUB       = 'pub'
        PURE      = 'pure'
        REF       = 'ref'
        RETURN    = 'return'
        CSELF     = 'Self'
        SELF      = 'self'
        SIZEOF    = 'sizeof'
        STATIC    = 'static'
        STRUCT    = 'struct'
        SUPER     = 'super'
        TRAIT     = 'trait'
        TRUE      = 'true'
        TYPE_KW   = 'type'
        TYPEOF    = 'typeof'
        UNSAFE    = 'unsafe'
        UNSIZED   = 'unsized'
        USE       = 'use'
        VIRTUAL   = 'virtual'
        WHERE     = 'where'
        WHILE     = 'while'
        YIELD     = 'yield'

        SHEBANG_LINE = '#!/bin/bash'

        // _DBG
        identifier  = 'regexp:\p{Alpha}\w*'
        space       = 'regexp:\s+'
    ]

    //
    //  Misc
    //

    elementType ("(Fn|Anon|Lambda|Path)Parameter") = ValueParameter
    elementType ("(Fn|Lambda|Path|FnType|ForeignFn|Method|MethodDecl)Parameters") = ValueParameterList

    extends     (".+Expr") = Expr
    elementType (".+BinExpr") = BinaryExpr
    extends     ("(?!RetType).*Type") = Type
    extends     ("Pat(Wild|Ref|Tup|Vec|Macro|Struct|Enum|Ident|Range|Uniq|QualPath)") = Pat

    elementType ("ExprLikeMacro|ItemLikeMacro") = Macro
    extends     ("(Try|FormatLike|Assert|AssertEq)Macro") = Macro
    elementType (".+MacroInvocation|MacroRulesInvocation") = MacroInvocation

    generateTokens=false
    generateTokenAccessors=true

    // Fast method sometimes fails to report syntax errors,
    // override it where it matters
    consumeTokenMethod("TypeAscription|InnerAttrsAndBlock") = "consumeToken"

    consumeTokenMethod(".*") = "consumeTokenFast"
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Root
///////////////////////////////////////////////////////////////////////////////////////////////////

File ::= [ SHEBANG_LINE ] InnerAttr* Items


///////////////////////////////////////////////////////////////////////////////////////////////////
// Attributes
///////////////////////////////////////////////////////////////////////////////////////////////////

fake Attr ::= MetaItem

InnerAttr ::= '#' '!' '[' MetaItem ']' { extends = Attr }
OuterAttr ::= '#'     '[' MetaItem ']' { extends = Attr }
private OuterAttr_first ::= '#'

MetaItem ::= IDENTIFIER [ '=' LitExpr | MetaItemArgs ]
MetaItemArgs ::= '(' [ <<comma_separated_list (MetaItem | LitExpr)>> ] ')'


///////////////////////////////////////////////////////////////////////////////////////////////////
// Paths
///////////////////////////////////////////////////////////////////////////////////////////////////

private PathIdent ::= !("union" IDENTIFIER) IDENTIFIER | SELF | SUPER | CSELF
fake Path ::= (Path '::')? PathIdent PathTypeArguments? {
  implements = [ "org.rust.lang.core.psi.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RsPathImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsPathStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private PathImpl ::= PathStart PathSegment*

PathStart ::= '::'?  PathIdent PathTypeArguments? { elementType = Path }
left PathSegment ::= '::' PathIdent PathTypeArguments? { elementType = Path }

private PathTypeArguments ::= <<isPathMode 'COLONS'>> ColonTypeArgumentList
                              | <<isPathMode 'NO_COLONS '>> ( TypeArgumentList | PathParameters RetType? ) // Fn(i32) -> i32 sugar

TypeArgumentList ::= TypeArgumentListImpl {
  extends = "org.rust.lang.core.psi.impl.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
ColonTypeArgumentList ::= '::' TypeArgumentListImpl { elementType = TypeArgumentList }

private TypeArgumentListImpl ::= '<' !'=' ( <<list_element (LIFETIME)>>*
                                               <<list_element (!(IDENTIFIER '=') Type)>>*
                                               <<list_element AssocTypeBinding>>*) '>' { pin = 2 }

AssocTypeBinding ::= IDENTIFIER '=' Type


// Paths (with `::` separating `generic_args` from actual name) used in expression contexts:
//    a::b::<T,U>::c
PathGenericArgsWithoutColons ::= <<pathMode 'NO_COLONS' PathImpl>> { elementType = Path }

// Paths (w/o types and therefore `generic_args`, containing only identifiers, `self`, etc.):
//    a::b::c
PathWithoutTypes ::= <<pathMode 'NO_TYPES' PathImpl>> { elementType = Path }

// Paths (w/o `::` separating `generic_args` from actual name) used in type contexts:
//    a::b<T,U>::c<V,W>
//    a::b<T,U>::c(V) -> W
//    a::b<T,U>::c(V)
PathGenericArgsWithColons ::= <<pathMode 'COLONS' PathImpl>> { elementType = Path }

// Qualified paths
//
//    <TYPE [as TRAIT_REF]> :: (path_without_types | path_generic_args_with_colons)
//
//    <T>::c<V,W>
//    <T as Foo>::c(V) -> W
private meta qualified_path ::= '<' Type [ AS TraitRef ] '>' '::' <<param>>

// Path semantically constrained to resolve to a trait
TraitRef ::= PathGenericArgsWithoutColons {
  extends = "org.rust.lang.core.psi.impl.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Items
///////////////////////////////////////////////////////////////////////////////////////////////////

Vis ::= PUB VisRestriction?
VisRestriction ::= '(' ( CRATE | PathWithoutTypes ) ')'

//XXX: don't use contextual keywords in recover, because they remap tokens.
private DEFAULT ::= <<defaultKeyword>>
private UNION ::= <<unionKeyword>>

private AttrsAndVis ::= OuterAttr* Vis?

private Item ::= Constant
               | TypeAlias
               | FnItem
               | TraitItem
               | ImplItem
               | ModDeclItem
               | ModItem
               | ForeignModItem
               | StructItem
               | EnumItem
               | ViewItem
               | MacroItem

private ItemWithRecover ::= !('}' | <<eof>>) Item {
  pin = 1
  recoverWhile = ItemRecover
}
private ItemRecover ::= !('}' | '#' | PUB | FN | CONST | EXTERN | UNSAFE | STRUCT | ENUM | USE | IDENTIFIER | MOD | TRAIT | STATIC | TYPE_KW | IMPL | "union")

private Items ::= ItemWithRecover*


///////////////////////////////////////////////////////////////////////////////////////////////////
// Functions
///////////////////////////////////////////////////////////////////////////////////////////////////

// Parameters
fake ValueParameter  ::= Pat? Type? {
  extends = "org.rust.lang.core.psi.impl.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

FnParameter ::= Pat TypeAscription
LambdaParameter ::= Pat TypeAscription?
AnonParameter ::= [ RestrictedPat ':' ] Type
PathParameter ::= Type !'='

fake ValueParameterList ::= SelfParameter? ValueParameter* '...'? {
  extends = "org.rust.lang.core.psi.impl.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

FnParameters          ::= '(' !',' [ <<comma_separated_list FnParameter>> ] ')' { pin = 1 }
LambdaParameters      ::= '|' !',' [ <<comma_separated_list LambdaParameter>> ] '|'

MethodParameters      ::= <<method_params_impl FnParameter>>
MethodDeclParameters ::= <<method_params_impl AnonParameter>>

ForeignFnParameters  ::= <<variadic_params_impl FnParameter>>
FnTypeParameters     ::= <<variadic_params_impl AnonParameter>>
PathParameters        ::= '(' [ <<comma_separated_list PathParameter>> ] ')' { pin = 1 }

private meta variadic_params_impl ::= '(' [ <<param>> (',' <<param>>)*  [ ',' '...'? ] ] ')' { pin = 1 }
private meta method_params_impl ::= '(' ( SelfParameter [ ',' [ <<comma_separated_list <<param>>>> ] ]
                                        | [ <<comma_separated_list <<param>>>> ] ) ')' { pin = 1 }

SelfParameter ::= [ '&' LIFETIME? ] MUT? SELF TypeAscription? {
  implements = [ "org.rust.lang.core.psi.RsNamedElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RsSelfParameterImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsSelfParameterStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private RestrictedPat ::= &( IDENTIFIER
                            | '_'
                            | '&' (IDENTIFIER | '_')
                            | '&' '&' (IDENTIFIER | '_')
                            | MUT IDENTIFIER
                            ) Pat

TypeParameterList ::= '<' LifetimesParams TypeParams '>' {
  extends = "org.rust.lang.core.psi.impl.RsStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private LifetimesParams ::= <<list_element LifetimeParameter>>*
private TypeParams      ::= <<list_element TypeParameter>>*

LifetimeParameter ::= LIFETIME LifetimeParamBounds? {
  implements = [ "org.rust.lang.core.psi.RsNamedElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RsLifetimeParameterImplMixin"
}

LifetimeParamBounds ::= ':' LIFETIME ('+' LIFETIME)*

TypeParameter ::= IDENTIFIER TypeParamBounds? [ '=' Type ] {
  implements = [ "org.rust.lang.core.psi.RsNamedElement" ]
  extends = "org.rust.lang.core.psi.impl.RsStubbedNamedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsTypeParameterStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

TypeParamBounds ::= ':' Polybound ('+' Polybound)*
Polybound ::= [ ForLifetimes | '?' ] Bound

WhereClause ::= WHERE <<comma_separated_list WherePred>>

WherePred ::= LIFETIME LifetimeParamBounds | ForLifetimes? Type TypeParamBounds

ForLifetimes ::= FOR '<' LifetimesParams '>'


private FnAttrs ::= CONST? UNSAFE? ExternAbi?
private FnHeader ::= FN IDENTIFIER TypeParameterList?
private FnTail ::= RetType? WhereClause?

ExternAbi ::= EXTERN STRING_LITERAL?

RetType ::= '->' Type { pin = 1 }

fake Function ::=
  OuterAttr* DEFAULT? Vis? FnAttrs FnHeader FnParameters FnTail (';' | InnerAttrsAndBlock)
{
  pin = FnHeader
  implements = [ "org.rust.lang.core.psi.RsQualifiedNamedElement"
                 "org.rust.lang.core.psi.RsGenericDeclaration"
                 "org.rust.lang.core.psi.RsOuterAttributeOwner"
                 "org.rust.lang.core.psi.RsInnerAttributeOwner"
                 "org.rust.lang.core.psi.RsTypeBearingItemElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RsFunctionImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsFunctionStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

ForeignFnDecl ::=
  OuterAttr*          Vis?          FnHeader ForeignFnParameters FnTail ';'
{
  pin = FnHeader
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  elementType = Function
}

FnItem ::=
  OuterAttr*          Vis? FnAttrs FnHeader FnParameters FnTail InnerAttrsAndBlock
{
  pin = FnHeader
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  elementType = Function
}

TraitMethodMember ::=
  OuterAttr*               FnAttrs FnHeader MethodDeclParameters FnTail (';' | InnerAttrsAndBlock)
{
  pin = FnHeader
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  elementType = Function
}

ImplMethodMember ::=
  OuterAttr* DEFAULT? Vis? FnAttrs FnHeader MethodParameters FnTail InnerAttrsAndBlock
{
  pin = FnHeader
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  elementType = Function
}

Pat ::= PatWild
      | PatRef
      | PatTup
      | PatVec
      | PatMacro
      | PatStruct
      | PatEnum
      | PatIdent
      | PatRange
      | PatUniq
      | PatQualPath

private Pat_first ::= '_' | '&' | '(' | '[' | IDENTIFIER | SELF | CSELF | SUPER | Lit | '::' | BOX | '<' | '-' | REF | MUT


PatQualPath   ::= <<qualified_path PathWithoutTypes>>
PatUniq        ::= BOX Pat

// XXX(matklad): it is impossible to distinguish between nullary enum variants
// and identifiers during parsing.
//
//   match x {
//       None => { } // match enum variant
//       Name => { } // bind Name to x
//   }
PatIdent       ::= PatBinding [ '@' Pat ]


PatStruct      ::= PathGenericArgsWithColons '{' PatFieldWithRecover* '..'? '}'
PatEnum        ::= PathGenericArgsWithColons '(' SeqPat ')'

// TODO: actual recover
private PatWithRecover ::= Pat (',' | &(')' | ']' | '..'))
private PatFieldWithRecover ::= PatField (',' | & '}')

PatRange ::= LitOrPath [ '...' LitOrPath ]
private LitOrPath ::= '-'? Lit | PathExpr

PatTup ::= '(' SeqPat ')'
PatVec ::= '[' SeqPat ']'
// NB: there are `[x, .. , y]` and `[x, z.. , y]`
private SeqPat ::= PatWithRecover* ['..' [',' PatWithRecover+] ]

PatRef ::= '&' MUT? Pat

PatWild ::= '_'
PatBinding ::= BindingMode? IDENTIFIER !'...' !'::' {
  implements = [ "org.rust.lang.core.psi.RsNamedElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RsPatBindingImplMixin"
}

PatField ::= IDENTIFIER ':' Pat
            | BOX? PatBinding

BindingMode ::= REF MUT? | MUT

Constant ::=
  OuterAttr* DEFAULT? Vis? (STATIC MUT? | CONST) IDENTIFIER TypeAscription [ '=' AnyExpr ] ';'
{
  pin = 'IDENTIFIER'
  implements = [ "org.rust.lang.core.psi.RsNamedElement"
                 "org.rust.lang.core.psi.RsItemElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RsConstantImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsConstantStub"
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private ViewItem ::= UseItem
                    | ExternCrateItem

UseItem ::= AttrsAndVis USE UsePath ';' {
  pin = "USE"
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.RsItemElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RsUseItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsUseItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private UsePath ::=
                  //  use ::{};
                  //  use {foo, bar};
                    '::'? UseGlobList
                  //  use foo::bar as baz;
                  //  use foo::bar::{self, foo};
                  //  use foo::{};
                  //  use ::foo::*;
                  | PathWithoutTypes ( Alias | '::' ( UseGlobList | '*' ) )?

UseGlobList ::= '{' UseGlobWithRecover* '}' {
  pin = 1
  extends = "org.rust.lang.core.psi.impl.RsStubbedElementImpl.WithParent<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

UseGlob ::= (IDENTIFIER | SELF) Alias? {
  implements = [ "org.rust.lang.core.psi.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RsUseGlobImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsUseGlobStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private UseGlobWithRecover ::= !'}' UseGlob (',' | &'}') {
  pin = 1
  recoverWhile = UseGlobRecover
}

private UseGlobRecover ::= !('}' | SELF | IDENTIFIER)

Alias ::= AS IDENTIFIER {
  implements = [ "org.rust.lang.core.psi.RsNamedElement" ]
  extends = "org.rust.lang.core.psi.impl.RsStubbedNamedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RsAliasStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

ExternCrateItem ::= AttrsAndVis EXTERN CRATE IDENTIFIER Alias? ';' {
  pin = "IDENTIFIER"
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.RsReferenceElement"
                 "org.rust.lang.core.psi.RsNamedElement"
                 "org.rust.lang.core.psi.RsItemElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RsExternCrateItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsExternCrateItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Mods
///////////////////////////////////////////////////////////////////////////////////////////////////

ModDeclItem ::= AttrsAndVis MOD IDENTIFIER ';' {
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.RsReferenceElement"
                 "org.rust.lang.core.psi.RsNamedElement"
                 "org.rust.lang.core.psi.RsItemElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RsModDeclItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsModDeclItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

ModItem ::= AttrsAndVis MOD IDENTIFIER '{' InnerAttr* Items '}' {
  pin = 4
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.RsNamedElement"
                 "org.rust.lang.core.psi.RsItemElement"
                 "org.rust.lang.core.psi.RsMod"
                 "org.rust.lang.core.psi.RsInnerAttributeOwner" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RsModItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsModItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

ForeignModItem ::= AttrsAndVis ExternAbi '{' InnerAttr* ForeignDecl* '}' {
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.RsItemElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RsForeignModItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private ForeignDecl ::= Constant | ForeignFnDecl


///////////////////////////////////////////////////////////////////////////////////////////////////
// Struct & Enums
///////////////////////////////////////////////////////////////////////////////////////////////////

StructItem ::= AttrsAndVis (STRUCT | UNION) IDENTIFIER TypeParameterList? (TupleFields? WhereClause? ';' | WhereClause? BlockFields) {
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.RsStructOrEnumItemElement"
                 "org.rust.lang.core.psi.RsFieldsOwner" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RsStructItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsStructItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

EnumItem ::= AttrsAndVis ENUM IDENTIFIER TypeParameterList? WhereClause? EnumBody {
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = "org.rust.lang.core.psi.RsStructOrEnumItemElement"
  mixin = "org.rust.lang.core.psi.impl.mixin.RsEnumItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsEnumItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

EnumBody ::= '{' [ <<comma_separated_list EnumVariant>> ] '}' {
  pin = 1
  extends = "org.rust.lang.core.psi.impl.RsStubbedElementImpl.WithParent<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
EnumVariant ::= OuterAttr* IDENTIFIER VariantArgs? {
  pin = 2
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.RsQualifiedNamedElement"
                 "org.rust.lang.core.psi.RsNamedElement"
                 "org.rust.lang.core.psi.RsOuterAttributeOwner"
                 "org.rust.lang.core.psi.RsFieldsOwner" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RsEnumVariantImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsEnumVariantStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private VariantArgs ::= VariantBlockFields
                       | VariantTupleFields
                       | VariantDiscriminant

BlockFields ::= <<mk_block_fileds FieldDecl>> {
  extends = "org.rust.lang.core.psi.impl.RsStubbedElementImpl.WithParent<?>"
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
TupleFields ::= <<mk_tuple_fields TupleFieldDecl>>

VariantBlockFields ::= <<mk_block_fileds VariantFieldDecl>> { elementType = BlockFields }
VariantTupleFields ::= <<mk_tuple_fields VariantTupleFieldDecl>> { elementType = TupleFields }

VariantDiscriminant ::= '=' AnyExpr { pin = 1 }

FieldDecl ::= AttrsAndVis IDENTIFIER TypeAscription {
  pin = 2
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.RsOuterAttributeOwner"
                 "org.rust.lang.core.psi.RsVisibilityOwner"
                 "org.rust.lang.core.psi.RsTupleOrStructFieldDeclElement"
                 "org.rust.lang.core.psi.RsNamedElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RsFieldDeclImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsFieldDeclStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
// unlike structs, enum variants can't have `pub` visibility applied to fields
VariantFieldDecl ::= OuterAttr* IDENTIFIER TypeAscription {
  pin = 2
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  elementType = FieldDecl
}

TupleFieldDecl ::= AttrsAndVis Type {
  implements = [ "org.rust.lang.core.psi.RsOuterAttributeOwner"
                 "org.rust.lang.core.psi.RsVisibilityOwner"
                 "org.rust.lang.core.psi.RsTupleOrStructFieldDeclElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RsTupleFieldDeclImplMixin"
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
}
VariantTupleFieldDecl ::= OuterAttr* Type {
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  elementType = TupleFieldDecl
}

private meta mk_block_fileds ::= '{' <<field_with_recover <<param>> >>* '}' { pin = 1}
private meta field_with_recover ::= !'}' <<param>> (',' | &'}') {
  pin = 1
  recoverWhile = FieldRecover
}
private FieldRecover ::= !('}' | '#' | PUB | IDENTIFIER)

private meta mk_tuple_fields ::= '(' <<comma_separated_list <<param>> >> ')' { pin = 1}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Trait
///////////////////////////////////////////////////////////////////////////////////////////////////

TraitItem ::= AttrsAndVis UNSAFE? TRAIT IDENTIFIER TypeParameterList? TypeParamBounds? WhereClause? TraitBody {
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.RsQualifiedNamedElement"
                 "org.rust.lang.core.psi.RsTypeBearingItemElement"
                 "org.rust.lang.core.psi.RsGenericDeclaration" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RsTraitItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsTraitItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private TraitBody ::= '{' TraitMember* '}' { pin = 1 }

// TODO: use upper rules and inheritance here
private TraitMember ::= !'}' ( Constant | TypeAlias | TraitMethodMember ) {
  pin = 1
  recoverWhile = TraitMemberRecover
}

private TraitMemberRecover ::= !('#' | Vis | EXTERN | CONST | STATIC | UNSAFE | FN | TYPE_KW | '}' | "default")


///////////////////////////////////////////////////////////////////////////////////////////////////
// Impl
///////////////////////////////////////////////////////////////////////////////////////////////////

ImplItem ::= AttrsAndVis UNSAFE? IMPL TypeParameterList? (ForImpl | BareImpl) {
  pin = "IMPL"
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.RsItemElement"
                 "org.rust.lang.core.psi.RsGenericDeclaration" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RsImplItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RsImplItemStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private BareImpl ::= Type !FOR WhereClause? ImplBody { pin = 2 }
private ForImpl ::= '!'? TraitRef FOR (AutoTraitImpl | TypeTraitImpl) { pin = 3 }
private AutoTraitImpl ::= '..' '{' '}' { pin = 1 }
private TypeTraitImpl ::= Type WhereClause? ImplBody { pin = 1 }

private ImplBody ::= '{' InnerAttr* ImplMember* '}' { pin = 1 }

private ImplMember ::= !'}' ( ImplMethodMember | Constant | ImplMacroMember | TypeAlias ) {
  pin = 1
  recoverWhile = ImplMemberRecover
}
private ImplMemberRecover ::= !('#' | Vis | EXTERN | CONST | STATIC | UNSAFE | FN | (IDENTIFIER '!') | TYPE_KW | "default" | '}')


///////////////////////////////////////////////////////////////////////////////////////////////////
// Types
///////////////////////////////////////////////////////////////////////////////////////////////////

private TypeAscription ::= ':' Type

Type ::= VecType
       | RefLikeType
       | BareFnType
       | TupleType
       | BaseType
       | TypeWithBoundsType
       | ForInType
       | ImplTraitType {

  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  extends = "org.rust.lang.core.psi.impl.RsStubbedElementImpl<?>"
}

VecType ::= '[' Type [';' AnyExpr] ']' {
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

RefLikeType ::= ( '&' LIFETIME? MUT? | '*' [ CONST | MUT ] ) Type {
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

BareFnType ::= [ UNSAFE? ExternAbi? ] FN FnTypeParameters RetType? {
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

TupleType ::= '(' [ <<comma_separated_list Type>> ] ')' {
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

TypeWithBoundsType ::= Type ('+' Bound)+ {
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
Bound ::= LIFETIME | TraitRef

ForInType ::= ForLifetimes (BareFnType | TraitRef) {
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

ImplTraitType ::= IMPL Polybound ('+' Polybound)* {
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

BaseType ::= '_' | '!' | !'<' PathGenericArgsWithoutColons | &'<' TypeQualPath {
  stubClass = "org.rust.lang.core.stubs.RsPlaceholderStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

TypeAlias ::=
  OuterAttr* DEFAULT? Vis? TYPE_KW IDENTIFIER ( TypeParameterList WhereClause? | WhereClause | TypeParamBounds )? [ '=' Type ] ';'
{
  pin = 'IDENTIFIER'
  implements = [ "org.rust.lang.core.psi.RsQualifiedNamedElement"
                 "org.rust.lang.core.psi.RsTypeBearingItemElement"
                 "org.rust.lang.core.psi.RsGenericDeclaration" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RsTypeAliasImplMixin"
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  stubClass = "org.rust.lang.core.stubs.RsTypeAliasStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

TypeQualPath ::= <<qualified_path PathWithoutTypes>>

///////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////////////////////////

// https://doc.rust-lang.org/reference.html#operator-precedence
// https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md#24-compact-expression-parsing-with-priorities
//
// Rust expression grammar allows or forbids struct literals depending on context.
// There are `no_struct_lit_expr` and `any_expr` productions for this two cases.
// `expr` production is an implementation detail. It passes the context information to the child expressions.
Expr ::= RetExpr
       | LambdaExpr
       | AssignBinExpr
       | BlockExpr
       | ContExpr
       | BreakExpr
       | FullRangeExpr
       | OpenRangeExpr
       | BoolOrBinExpr
       | BoolAndBinExpr
       | CompBinExpr
       | RelCompBinExpr
       | BitOrBinExpr
       | BitXorBinExpr
       | BitAndBinExpr
       | BitShiftBinExpr
       | AddBinExpr
       | MulBinExpr
       | CastExpr
       | UnaryExpr
       | TryExpr
       | AtomExpr

// https://github.com/rust-lang/rfcs/blob/master/text/0092-struct-grammar.md
NoStructLitExpr ::= <<structLiterals 'OFF' <<stmtMode 'OFF' Expr>> >> { elementType = Expr }
AnyExpr ::= <<structLiterals 'ON' <<stmtMode 'OFF' Expr>> >> { elementType = Expr }
StmtModeExpr ::= <<structLiterals 'ON' <<stmtMode 'ON' Expr>> >> { elementType = Expr }
StmtModeExprOff ::= <<stmtMode 'OFF' Expr>> { elementType = Expr }


BlockExpr ::= WhileExpr
             | IfExpr
             | ForExpr
             | LoopExpr
             | MatchExpr
             | (UNSAFE &'{')? SimpleBlock


private AtomExpr ::= LitExpr
                    | MacroExpr
                    | StructExpr
                    | QualPathExpr
                    | MethodCallExpr
                    | FieldExpr
                    | IndexExpr
                    | PathExpr !'('
                    | CallExpr
                    | ArrayExpr
                    | UnitExpr
                    | TupleOrParenExpr


fake BinaryExpr ::= Expr+ {
  methods=[
    left="/Expr[0]"
    right="/Expr[1]"
  ]
}

AssignBinExpr ::= Expr
                  ( gtgteq
                  | ltlteq
                  | '|='
                  | '^='
                  | '&='
                  | '='
                  | '+='
                  | '-='
                  | '*='
                  | '/='
                  | '%='
                  ) Expr    { rightAssociative = true }

CompBinExpr       ::= Expr !<<isCompleteBlockExpr>> ('==' | '!=') StmtModeExprOff
RelCompBinExpr   ::= Expr !<<isCompleteBlockExpr>> ('<' !('<' | '=') | '>' !('>' | '=') | lteq | gteq) StmtModeExprOff
BitShiftBinExpr  ::= Expr !<<isCompleteBlockExpr>> (ltlt | gtgt) StmtModeExprOff
AddBinExpr        ::= Expr !<<isCompleteBlockExpr>> ('+' | '-') StmtModeExprOff
MulBinExpr        ::= Expr !<<isCompleteBlockExpr>> ('*' | '/' | '%') StmtModeExprOff

// <expr> | <expr> has higher priority than <expr> || <expr>
BoolOrBinExpr    ::= Expr !<<isCompleteBlockExpr>> oror StmtModeExprOff
BoolAndBinExpr   ::= Expr !<<isCompleteBlockExpr>> andand StmtModeExprOff
BitOrBinExpr     ::= Expr !(<<isCompleteBlockExpr>> | oror)   '|' StmtModeExprOff
BitAndBinExpr    ::= Expr !(<<isCompleteBlockExpr>> | andand) '&' StmtModeExprOff
BitXorBinExpr    ::= Expr !<<isCompleteBlockExpr>> '^' StmtModeExprOff


CastExpr ::= Expr AS Type

TryExpr ::= Expr '?'

UnaryExpr ::= (BOX | '-' | '*' | '!' | '&' MUT?) Expr

LambdaExpr ::= MOVE? LambdaParameters RetType? AnyExpr

StructExpr ::= <<checkStructAllowed>> PathGenericArgsWithColons StructExprBody

StructExprBody ::= '{' [ <<comma_separated_list StructExprField>> ] ('..'  AnyExpr)? '}' {
  pin = 1
}

StructExprField ::= IDENTIFIER ':' AnyExpr {
  pin = 1
  recoverWhile = StructExprFieldRecover
  implements = [ "org.rust.lang.core.psi.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RsStructExprFieldImplMixin"
}
private StructExprFieldRecover ::= !(IDENTIFIER | ',' | '}' | '..')

PathExpr ::= PathGenericArgsWithColons

QualPathExpr ::= << qualified_path PathGenericArgsWithColons >>

WhileExpr ::= Label? WHILE Condition SimpleBlock { pin = 'WHILE' }
Condition ::= (LET Pat '=')? NoStructLitExpr

LoopExpr ::= Label? LOOP SimpleBlock { pin = 'LOOP' }
private Label ::= LIFETIME ':'

ContExpr ::= CONTINUE LIFETIME?

BreakExpr ::= BREAK LIFETIME?

ForExpr ::= Label? FOR Pat IN NoStructLitExpr SimpleBlock { pin = "FOR" }

MatchExpr ::= MATCH NoStructLitExpr MatchBody { pin = 'MATCH'}
MatchBody ::= '{' MatchArm* '}' { pin = 1 }
MatchArm ::= OuterAttr* MatchPat '=>' StmtModeExpr (',' | (&'}' | <<isBlock>>)) {
  pin = 2
  recoverWhile = MatchArmRecover
}
private MatchArmRecover ::= !(Pat_first | OuterAttr_first | '}')
MatchPat ::= Pat ('|' Pat)* (IF AnyExpr)?

IfExpr ::= IF Condition SimpleBlock ElseBranch? { pin = 'IF' }
ElseBranch ::= ELSE ( IfExpr | SimpleBlock )

RetExpr ::= RETURN Expr?

UnitExpr ::= '(' ')'

// It is possible to distinguish between paren_expr (any_expr) and a single element
// tuple_expr (any_expr,) only after almost all input has been consumed. That is, it's
// not LL(k) for any k. So let's use a custom rule to avoid exponential backtracking.
TupleOrParenExpr ::= << tupleOrParenExpr AnyExpr TupleExprEnd ParenExprEnd >>

// Used by `tupleOrParenExpr`
TupleExpr ::= '(' AnyExpr TupleExprEnd
private TupleExprEnd ::= ',' [ AnyExpr (',' AnyExpr)* ','? ] ')'

// Used by `tupleOrParenExpr`
ParenExpr ::= '(' AnyExpr ParenExprEnd
private ParenExprEnd ::= ')'

ArrayExpr ::= '[' ArrayInitializer ']' { pin = 1 }
private ArrayInitializer ::= [ AnyExpr ( ';' AnyExpr | (',' AnyExpr)* ','? ) ]

fake RangeExpr ::= Expr + {
  methods=[
    from="/Expr[0]"
    to="/Expr[1]"
  ]
}

FullRangeExpr ::= Expr ( '..' (&<<checkBraceAllowed>> Expr)? | '...' (&<<checkBraceAllowed>> Expr) ) { elementType = RangeExpr }
OpenRangeExpr ::=      ( '..' (&<<checkBraceAllowed>> Expr)? | '...' (&<<checkBraceAllowed>> Expr) ) { elementType = RangeExpr }


IndexExpr ::= Expr IndexArg
// Do not inline this rule, it breaks expression parsing
private IndexArg ::= '[' Expr ']'

CallExpr ::= Expr !<<isCompleteBlockExpr>> ValueArgumentList

MethodCallExpr ::= Expr '.' IDENTIFIER ColonTypeArgumentList? ValueArgumentList {
  implements = [ "org.rust.lang.core.psi.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RsMethodCallExprImplMixin"
}

ValueArgumentList ::= '(' ExprList? ')' { pin = 1 }

private ExprList ::= <<comma_separated_list AnyExpr>>

FieldId ::= IDENTIFIER | INTEGER_LITERAL

FieldExpr ::= Expr '.' FieldId {
  implements = [ "org.rust.lang.core.psi.RsReferenceElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RsFieldExprImplMixin"
}

LitExpr ::= Lit


///////////////////////////////////////////////////////////////////////////////////////////////////
// Macros
///////////////////////////////////////////////////////////////////////////////////////////////////

fake Macro ::= MacroInvocation MacroArg?

// Various kinds of macros
ExprLikeMacro ::= MacroInvocation MacroArg
ItemLikeMacro ::= MacroInvocation ItemMacroArg

TryMacro ::= TryMacroInvocation TryMacroArgs { pin = 1 }
FormatLikeMacro ::= FormatLikeMacroInvocation FormatMacroArgs { pin = 1 }
AssertMacro ::= AssertMacroInvocation AssertMacroArgs { pin = 1 }
AssertEqMacro ::= AssertEqMacroInvocation AssertEqMacroArgs { pin = 1 }

VecMacro ::= VecMacroInvocation VecMacroArgs { pin = 1 }
LogMacro ::= LogMacroInvocation LogMacroArgs { pin = 1 }

MacroDefinition ::= MacroRulesInvocation IDENTIFIER ItemMacroArg {
  pin = 1
  extends = ItemLikeMacro
}

private BuildInMacro ::= TryMacro
                         | FormatLikeMacro
                         | AssertMacro
                         | AssertEqMacro
                         | VecMacro
                         | LogMacro

private ZzMacroCall ::= BuildInMacro | ExprLikeMacro { pin(".*") = MacroInvocation }
private ZzMacroItem ::= MacroDefinition | ItemLikeMacro {
  pin(".*") = MacroInvocation
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
}

// Invocations
MacroInvocation ::= IDENTIFIER '!' IDENTIFIER?
TryMacroInvocation ::= "try" '!'
VecMacroInvocation ::= "vec" '!'
LogMacroInvocation ::= ( "trace" | "log" | "warn" | "debug" | "error" | "info" ) '!'
MacroRulesInvocation ::= "macro_rules" '!'

// https://doc.rust-lang.org/std/fmt/
FormatLikeMacroInvocation ::= ( "format"
                                 | "format_args"
                                 | "write"
                                 | "writeln"
                                 | "print"
                                 | "println"
                                 | "panic") '!'

AssertMacroInvocation ::= ( "assert"
                            | "debug_assert") '!'

AssertEqMacroInvocation ::= ( "assert_eq"
                               | "assert_ne"
                               | "debug_assert_eq"
                               | "debug_assert_ne") '!'

// Arguments
MacroArg ::= <<macro_args_delim TokenTrees>>

ItemMacroArg ::= '(' TokenTrees ')' ';'
                 | '{' TokenTrees '}'
                 | '[' TokenTrees ']' ';' {
  pin = 1
  elementType = MacroArg
}

TryMacroArgs ::= <<macro_args_delim AnyExpr>>
VecMacroArgs ::= '[' ArrayInitializer ']'  { pin = 1 }

private ZzLogMacroArgs ::= ('target' ':' Expr ','?)? (<<comma_separated_list FormatMacroArg>>)?
LogMacroArgs ::=  <<macro_args_delim ZzLogMacroArgs>>

private ZzAssertMacroArgs ::= AnyExpr [ ',' <<comma_separated_list FormatMacroArg>> ]
AssertMacroArgs ::= <<macro_args_delim ZzAssertMacroArgs>>

private ZzAssertEqMacroArgs ::= AnyExpr ',' AnyExpr [ ',' <<comma_separated_list FormatMacroArg>> ]
AssertEqMacroArgs ::= <<macro_args_delim ZzAssertEqMacroArgs>>

FormatMacroArgs ::= <<macro_args_delim [ <<comma_separated_list FormatMacroArg>> ] >>
FormatMacroArg ::= [ IDENTIFIER '=' ] AnyExpr

private meta macro_args_delim ::= '(' <<param>> ')'
                                | '{' <<param>> '}'
                                | '[' <<param>> ']' { pin = 1 }

// Macro wrappers
MacroExpr ::= ZzMacroCall
PatMacro  ::= ZzMacroCall
// TODO: Maybe implement item-related stuff for this production?
MacroItem ::= AttrsAndVis ZzMacroItem {
    implements = [ "org.rust.lang.core.psi.RsOuterAttributeOwner" ]
}
ImplMacroMember ::= ZzMacroItem

private TokenTrees ::= TokenTree*

TokenTree ::= '(' TokenTrees ')'
             | '{' TokenTrees '}'
             | '[' TokenTrees ']'
             | << unpairedToken >> +


Lit ::= STRING_LITERAL | BYTE_STRING_LITERAL
      | RAW_STRING_LITERAL | RAW_BYTE_STRING_LITERAL
      | CHAR_LITERAL | BYTE_LITERAL
      | INTEGER_LITERAL | FLOAT_LITERAL
      | FALSE | TRUE


///////////////////////////////////////////////////////////////////////////////////////////////////
// Statements
///////////////////////////////////////////////////////////////////////////////////////////////////

fake Block ::= '{' InnerAttr* (Item | Stmt)* Expr? '}' {
  pin = 1
  implements = "org.rust.lang.core.psi.RsItemsOwner"
}

SimpleBlock ::= '{' BlockTail '}' {
  pin = 1
  elementType = Block
}

InnerAttrsAndBlock ::= '{' InnerAttr* BlockTail '}' {
  pin = 1
  elementType = Block
}

private BlockTail ::= (ExprStmtOrLastExpr | Stmt | Item)* { recoverWhile = BlockRecover }
private BlockRecover ::= !('}')

Stmt ::= LetDecl | EmptyStmt | never ';'

ExprStmtOrLastExpr ::= OuterAttr? StmtModeExpr (ExprStmtUpper | LastExprUpper)

upper ExprStmtUpper ::= ';' | () <<isBlock>> !('}') { elementType = ExprStmt }
upper LastExprUpper ::= () &'}' { elementType = Expr pin = 1 }

fake ExprStmt ::= OuterAttr? AnyExpr ';'? { extends = Stmt }

LetDecl ::= OuterAttr? LET Pat TypeAscription? [ '=' AnyExpr ] ';' {
  extends = Stmt
  pin = "LET"
}

EmptyStmt ::= ';' {
  extends = Stmt
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Utils
///////////////////////////////////////////////////////////////////////////////////////////////////

private gtgteq ::= <<gtgteqImpl>>  | never GTGTEQ { name = ">>=" }
private gtgt   ::= <<gtgtImpl>>    | never GTGT   { name = ">>" }
private gteq   ::= <<gteqImpl>>    | never GTEQ   { name = ">=" }
private ltlteq ::= <<ltlteqImpl>>  | never LTLTEQ { name = "<<=" }
private ltlt   ::= <<ltltImpl>>    | never LTLT   { name = "<<" }
private lteq   ::= <<lteqImpl>>    | never LTEQ   { name = "<=" }
private oror   ::= <<ororImpl>>    | never OROR   { name = "||" }
private andand ::= <<andandImpl>>  | never ANDAND { name = "&&" }

private never ::= !()

// Trailing commas are allowed
private meta comma_separated_list ::= <<param>> ( ',' <<param>> )* ','?
private meta list_element ::= <<param>> (',' | &'>') { pin = 1 }
