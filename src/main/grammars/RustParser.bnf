
{
    parserClass='org.rust.lang.core.parser.RustParser'
    parserUtilClass='org.rust.lang.core.parser.RustParserUtil'
    psiTreeUtilClass='org.rust.lang.core.parser.RustPsiTreeUtil'

    implements='org.rust.lang.core.psi.RustCompositeElement'
    extends='org.rust.lang.core.psi.impl.RustCompositeElementImpl'

    elementTypeHolderClass='org.rust.lang.core.psi.RustCompositeElementTypes'

    elementTypeClass='org.rust.lang.core.psi.RustCompositeElementType'
    tokenTypeClass='org.rust.lang.core.psi.RustTokenType'

    psiClassPrefix='Rust/Element'
    psiImplClassSuffix='Impl'
    psiPackage='org.rust.lang.core.psi'
    psiImplPackage='org.rust.lang.core.psi.impl'

    parserImports=[
      'static org.rust.lang.core.psi.RustTokenElementTypes.*'
      'static org.rust.lang.core.parser.RustParserUtil.PathParsingMode.*'
      'static org.rust.lang.core.parser.RustParserUtil.BinaryMode.*'
    ]


    tokens = [
        LBRACE               =  '{'
        RBRACE               =  '}'
        LBRACK               =  '['
        RBRACK               =  ']'
        LPAREN               =  '('
        RPAREN               =  ')'
        COLON                =  ':'
        COLONCOLON           =  '::'
        SEMICOLON            =  ';'
        COMMA                =  ','
        EQ                   =  '='
        EXCLEQ               =  '!='
        EQEQ                 =  '=='
        SHA                  =  '#'
        EXCL                 =  '!'
        PLUSEQ               =  '+='
        PLUS                 =  '+'
        MINUSEQ              =  '-='
        MINUS                =  '-'
        OREQ                 =  '|='
        ANDAND               =  '&&'
        ANDEQ                =  '&='
        AND                  =  '&'
        OR                   =  '|'
        LT                   =  '<'
        XOREQ                =  '^='
        XOR                  =  '^'
        MULEQ                =  '*='
        MUL                  =  '*'
        DIVEQ                =  '/='
        DIV                  =  '/'
        REMEQ                =  '%='
        REM                  =  '%'
        GT                   =  '>'
        DOT                  =  '.'
        DOTDOT               =  '..'
        DOTDOTDOT            =  '...'
        FAT_ARROW            =  '=>'
        ARROW                =  '->'
        Q                    =  '?'
        AT                   =  '@'
        UNDERSCORE           =  '_'

        // DEBUG

        ABSTRACT  = 'abstract'
        ALIGNOF   = 'alignof'
        AS        = 'as'
        BECOME    = 'become'
        BOX       = 'box'
        BREAK     = 'break'
        CONST     = 'const'
        CONTINUE  = 'continue'
        CRATE     = 'crate'
        DO        = 'do'
        ELSE      = 'else'
        ENUM      = 'enum'
        EXTERN    = 'extern'
        FALSE     = 'false'
        FINAL     = 'final'
        FN        = 'fn'
        FOR       = 'for'
        IF        = 'if'
        IMPL      = 'impl'
        IN        = 'in'
        LET       = 'let'
        LOOP      = 'loop'
        MACRO     = 'macro'
        MATCH     = 'match'
        MOD       = 'mod'
        MOVE      = 'move'
        MUT       = 'mut'
        OFFSETOF  = 'offsetof'
        OVERRIDE  = 'override'
        PRIV      = 'priv'
        PROC      = 'proc'
        PUB       = 'pub'
        PURE      = 'pure'
        REF       = 'ref'
        RETURN    = 'return'
        CSELF     = 'Self'
        SELF      = 'self'
        SIZEOF    = 'sizeof'
        STATIC    = 'static'
        STRUCT    = 'struct'
        SUPER     = 'super'
        TRAIT     = 'trait'
        TRUE      = 'true'
        TYPE_KW   = 'type'
        TYPEOF    = 'typeof'
        UNSAFE    = 'unsafe'
        UNSIZED   = 'unsized'
        USE       = 'use'
        VIRTUAL   = 'virtual'
        WHERE     = 'where'
        WHILE     = 'while'
        YIELD     = 'yield'

        SHEBANG_LINE = '#!/bin/bash'

        // _DBG
        identifier  = 'regexp:\p{Alpha}\w*'
        space       = 'regexp:\s+'
    ]

    //
    // References
    //

    mixin       ("path") = "org.rust.lang.core.psi.impl.mixin.RustPathImplMixin"
    implements  ("path") = "org.rust.lang.core.psi.RustReferenceElement"

    //
    //  Misc
    //

    implements  ("pat_binding") = [ "org.rust.lang.core.psi.RustNamedElement" ]
    mixin       ("pat_binding") = "org.rust.lang.core.psi.impl.mixin.RustPatBindingImplMixin"

    implements  ("alias") = "org.rust.lang.core.psi.RustNamedElement"
    extends     ("alias") = "org.rust.lang.core.psi.impl.RustNamedElementImpl"

    implements  ("self_argument") = [ "org.rust.lang.core.psi.RustNamedElement" ]
    mixin       ("self_argument") = "org.rust.lang.core.psi.impl.mixin.RustSelfArgumentImplMixin"

    mixin       ("use_glob") = "org.rust.lang.core.psi.impl.mixin.RustUseGlobImplMixin"

    elementType (".*_bin_expr")   = binary_expr
    elementType (".*_range_expr") = range_expr

    elementType ("(fn|anon|lambda|path)_parameter") = parameter
    elementType ("(fn|lambda|path)_parameters|method_parameters|method_decl_parameters") = parameters
    elementType ("(fn_type|foreign_fn)_parameters") = variadic_parameters

    extends     (".*_expr") = expr
    extends     ("(?!ret_type).*_type") = type
    extends     ("pat_(wild|ref|tup|vec|macro|struct|enum|ident|range|uniq|qual_path)")  = pat

    elementType ("expr_like_macro|item_like_macro") = macro
    extends     ("(try|format_like|assert|assert_eq)_macro") = macro
    elementType (".*_macro_invocation|macro_rules_invocation") = macro_invocation

    generateTokens=false
    generateTokenAccessors=true

    // Fast method sometimes fails to report syntax errors,
    // override it where it matters
    consumeTokenMethod("type_ascription") = "consumeToken"
    consumeTokenMethod("inner_attrs_and_block") = "consumeToken"

    consumeTokenMethod(".*") = "consumeTokenFast"

    //recoverWhile = skip_until_eol_rec
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Root
///////////////////////////////////////////////////////////////////////////////////////////////////

file ::= [ SHEBANG_LINE ] inner_attr* items


///////////////////////////////////////////////////////////////////////////////////////////////////
// Attributes
///////////////////////////////////////////////////////////////////////////////////////////////////

fake attr ::= meta_item

inner_attr ::= '#' '!' '[' meta_item ']' { extends = attr }
outer_attr ::= '#'     '[' meta_item ']' { extends = attr }
private first_outer_attr ::= '#'

meta_item ::= IDENTIFIER [ '=' lit_expr | meta_item_args ]
meta_item_args ::= '(' [ <<comma_separated_list (meta_item | lit_expr)>> ] ')'


///////////////////////////////////////////////////////////////////////////////////////////////////
// Paths
///////////////////////////////////////////////////////////////////////////////////////////////////

private path_ident ::= IDENTIFIER | SELF | SUPER | CSELF
fake path ::= (path '::')? path_ident path_generics? {
  stubClass = "org.rust.lang.core.stubs.RustPathElementStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private path_impl ::= path_start path_segment*

path_start ::= '::'?  path_ident path_generics? { elementType = path }
left path_segment ::= '::' path_ident path_generics? { elementType = path }

private path_generics ::= <<isPathMode 'COLONS'>> colon_generic_args
                        | <<isPathMode 'NO_COLONS '>> ( generic_args | path_parameters ret_type? ) // Fn(i32) -> i32 sugar

generic_args ::= generic_args_impl
colon_generic_args ::= '::' generic_args_impl { elementType = generic_args }

private generic_args_impl ::= '<' !'=' ( <<list_element (LIFETIME)>>*
                                         <<list_element (!(IDENTIFIER '=') type)>>*
                                         <<list_element assoc_type_binding>>*) '>' { pin = 2 }

assoc_type_binding ::= IDENTIFIER '=' type


// Paths (with `::` separating `generic_args` from actual name) used in expression contexts:
//    a::b::<T,U>::c
path_generic_args_without_colons ::= <<pathMode 'NO_COLONS' path_impl>> { elementType = path }

// Paths (w/o types and therefore `generic_args`, containing only identifiers, `self`, etc.):
//    a::b::c
path_without_types ::= <<pathMode 'NO_TYPES' path_impl>> { elementType = path }

// Paths (w/o `::` separating `generic_args` from actual name) used in type contexts:
//    a::b<T,U>::c<V,W>
//    a::b<T,U>::c(V) -> W
//    a::b<T,U>::c(V)
path_generic_args_with_colons ::= <<pathMode 'COLONS' path_impl>> { elementType = path }

// Qualified paths
//
//    <TYPE [as TRAIT_REF]> :: (path_without_types | path_generic_args_with_colons)
//
//    <T>::c<V,W>
//    <T as Foo>::c(V) -> W
private meta qualified_path ::= '<' type [ AS trait_ref ] '>' '::' <<param>>

// Path semantically constrained to resolve to a trait
trait_ref ::= path_generic_args_without_colons


///////////////////////////////////////////////////////////////////////////////////////////////////
// Items
///////////////////////////////////////////////////////////////////////////////////////////////////

vis ::= PUB

//XXX: don't use contextual keywords in recover, because they remap tokens.
private DEFAULT ::= <<defaultKeyword>>
private UNION ::= <<unionKeyword>>

private attrs_and_vis ::= outer_attr* vis?
private attrs_default_vis ::= outer_attr* DEFAULT? vis?

private item ::= constant
               | type_item
               | fn_item
               | trait_item
               | impl_item
               | mod_decl_item
               | mod_item
               | foreign_mod_item
               | struct_item
               | union_item
               | enum_item
               | view_item
               | macro_item

private item_with_recover ::= !('}' | <<eof>>) item {
  pin = 1
  recoverWhile = item_recover
}
private item_recover ::= !('}' | '#' | PUB | FN | CONST | EXTERN | UNSAFE | STRUCT | ENUM | USE | IDENTIFIER | MOD | TRAIT | STATIC | TYPE_KW | IMPL | "union")

private items ::= item_with_recover*


///////////////////////////////////////////////////////////////////////////////////////////////////
// Functions
///////////////////////////////////////////////////////////////////////////////////////////////////

// Parameters
// TODO: Maybe enforce @NotNull's in specific cases
fake parameter  ::= pat? type?

fn_parameter ::= pat type_ascription
lambda_parameter ::= pat type_ascription?
anon_parameter ::= [ restricted_pat ':' ] type
path_parameter ::= type !'='

fake parameters          ::= self_argument? parameter*
fake variadic_parameters ::= self_argument? parameter* '...'? { extends = parameters }

fn_parameters          ::= '(' !',' [ <<comma_separated_list fn_parameter>> ] ')' { pin = 1 }
lambda_parameters      ::= '|' !',' [ <<comma_separated_list lambda_parameter>> ] '|'

method_parameters      ::= <<method_params_impl fn_parameter>>
method_decl_parameters ::= <<method_params_impl anon_parameter>>

foreign_fn_parameters  ::= <<variadic_params_impl fn_parameter>>
fn_type_parameters     ::= <<variadic_params_impl anon_parameter>>
path_parameters        ::= '(' [ <<comma_separated_list path_parameter>> ] ')' { pin = 1 }

private meta variadic_params_impl ::= '(' [ <<param>> (',' <<param>>)*  [ ',' '...'? ] ] ')' { pin = 1 }
private meta method_params_impl ::= '(' ( self_argument [ ',' [ <<comma_separated_list <<param>>>> ] ]
                                        | [ <<comma_separated_list <<param>>>> ] ) ')' { pin = 1 }

self_argument ::= [ '&' LIFETIME? ] MUT? SELF type_ascription?
private restricted_pat ::= &( IDENTIFIER
                            | '_'
                            | '&' (IDENTIFIER | '_')
                            | '&' '&' (IDENTIFIER | '_')
                            | MUT IDENTIFIER
                            ) pat

generic_params ::= '<' lifetimes_params type_params '>'

private lifetimes_params ::= <<list_element lifetime_param>>*
private type_params      ::= <<list_element type_param>>*

lifetime_param ::= LIFETIME lifetime_param_bounds?
lifetime_param_bounds ::= ':' LIFETIME ('+' LIFETIME)*

type_param ::= IDENTIFIER type_param_bounds? [ '=' type ] {
  implements = [ "org.rust.lang.core.psi.RustNamedElement" ]
  extends = "org.rust.lang.core.psi.impl.RustNamedElementImpl"
}
type_param_bounds ::= ':' polybound ('+' polybound)*
polybound ::= [ for_lifetimes | '?' ] bound

where_clause ::= WHERE <<comma_separated_list where_pred>>

where_pred ::= LIFETIME lifetime_param_bounds | for_lifetimes? type type_param_bounds

for_lifetimes ::= FOR '<' lifetimes_params '>'


private fn_attrs ::= CONST? UNSAFE? extern_abi?
private fn_header ::= FN IDENTIFIER generic_params?
private fn_tail ::= ret_type? where_clause?

extern_abi ::= EXTERN STRING_LITERAL?

ret_type ::= '->' type { pin = 1 }

fake function ::=
  outer_attr* DEFAULT? vis? fn_attrs fn_header fn_parameters fn_tail (';' | inner_attrs_and_block)
{
  pin = fn_header
  implements = [ "org.rust.lang.core.psi.RustQualifiedNameOwner"
                 "org.rust.lang.core.psi.RustGenericDeclaration"
                 "org.rust.lang.core.psi.RustOuterAttributeOwner"
                 "org.rust.lang.core.psi.RustInnerAttributeOwner"
                 "org.rust.lang.core.psi.RustTypeBearingItemElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RustFunctionImplMixin"
  stubClass = "org.rust.lang.core.stubs.RustFunctionElementStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

foreign_fn_decl ::=
  outer_attr*          vis?          fn_header foreign_fn_parameters fn_tail ';'
{
  pin = fn_header
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  elementType = function
}

fn_item ::=
  outer_attr*          vis? fn_attrs fn_header fn_parameters fn_tail inner_attrs_and_block
{
  pin = fn_header
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  elementType = function
}

trait_method_member ::=
  outer_attr*               fn_attrs fn_header method_decl_parameters fn_tail (';' | inner_attrs_and_block)
{
  pin = fn_header
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  elementType = function
}

impl_method_member ::=
  outer_attr* DEFAULT? vis? fn_attrs fn_header method_parameters fn_tail inner_attrs_and_block
{
  pin = fn_header
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  elementType = function
}

pat ::= pat_wild
      | pat_ref
      | pat_tup
      | pat_vec
      | pat_macro
      | pat_struct
      | pat_enum
      | pat_ident
      | pat_range
      | pat_uniq
      | pat_qual_path

private first_pat ::= '_' | '&' | '(' | '[' | IDENTIFIER | SELF | CSELF | SUPER | lit | '::' | BOX | '<' | '-' | REF | MUT


pat_qual_path   ::= <<qualified_path path_without_types>>
pat_uniq        ::= BOX pat

// XXX(matklad): it is impossible to distinguish between nullary enum variants
// and identifiers during parsing.
//
//   match x {
//       None => { } // match enum variant
//       Name => { } // bind Name to x
//   }
pat_ident       ::= pat_binding [ '@' pat ]


pat_struct      ::= path_generic_args_with_colons '{' pat_field_with_recover* '..'? '}'
pat_enum        ::= path_generic_args_with_colons '(' seq_pat ')'

// TODO: actual recover
private pat_with_recover ::= pat (',' | &(')' | ']' | '..'))
private pat_field_with_recover ::= pat_field (',' | & '}')

pat_range ::= lit_or_path [ '...' lit_or_path ]
private lit_or_path ::= '-'? lit | path_expr

pat_tup ::= '(' seq_pat ')'
pat_vec ::= '[' seq_pat ']'
// NB: there are `[x, .. , y]` and `[x, z.. , y]`
private seq_pat ::= pat_with_recover* ['..' [',' pat_with_recover+] ]

pat_ref ::= '&' MUT? pat

pat_wild ::= '_'
pat_binding ::= binding_mode? IDENTIFIER !'...' !'::'

pat_field ::= IDENTIFIER ':' pat
            | BOX? pat_binding

binding_mode ::= REF MUT? | MUT

constant ::=
  outer_attr* DEFAULT? vis? (STATIC MUT? | CONST) IDENTIFIER type_ascription [ '=' any_expr ] ';'
{
  pin = 'IDENTIFIER'
  implements = [ "org.rust.lang.core.psi.RustNamedElement"
                 "org.rust.lang.core.psi.RustItemElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RustConstantImplMixin"
  stubClass = "org.rust.lang.core.stubs.RustConstantElementStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private view_item ::= use_item
                    | extern_crate_item

use_item ::= attrs_and_vis USE use_path ';' {
  pin = "USE"
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.RustItemElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RustUseItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RustUseItemElementStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private use_path ::=
                  //  use ::{};
                  //  use {foo, bar};
                    '::'? use_glob_list
                  //  use foo::bar as baz;
                  //  use foo::bar::{self, foo};
                  //  use foo::{};
                  //  use ::foo::*;
                  | path_without_types ( alias | '::' ( use_glob_list | '*' ) )?

use_glob_list ::= '{' use_glob_with_recover* '}' {
  pin = 1
  extends = "org.rust.lang.core.psi.impl.RustStubbedElementImpl.WithParent<?>"
  stubClass = "org.rust.lang.core.stubs.RustUseGlobListElementStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

use_glob ::= (IDENTIFIER | SELF) alias? {
  implements = [ "org.rust.lang.core.psi.RustReferenceElement" ]
  extends = "org.rust.lang.core.psi.impl.RustStubbedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RustUseGlobElementStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private use_glob_with_recover ::= !'}' use_glob (',' | &'}') {
  pin = 1
  recoverWhile = use_glob_recover
}

private use_glob_recover ::= !('}' | SELF | IDENTIFIER)

alias ::= AS IDENTIFIER {
  extends = "org.rust.lang.core.psi.impl.RustStubbedNamedElementImpl<?>"
  stubClass = "org.rust.lang.core.stubs.RustAliasElementStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

extern_crate_item ::= attrs_and_vis EXTERN CRATE IDENTIFIER alias? ';' {
  pin = "IDENTIFIER"
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.RustReferenceElement"
                 "org.rust.lang.core.psi.RustNamedElement"
                 "org.rust.lang.core.psi.RustItemElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RustExternCrateItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RustExternCrateItemElementStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Mods
///////////////////////////////////////////////////////////////////////////////////////////////////

mod_decl_item ::= attrs_and_vis MOD IDENTIFIER ';' {
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.RustReferenceElement"
                 "org.rust.lang.core.psi.RustNamedElement"
                 "org.rust.lang.core.psi.RustItemElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RustModDeclItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RustModDeclItemElementStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

mod_item ::= attrs_and_vis MOD IDENTIFIER '{' inner_attr* items '}' {
  pin = 4
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.RustNamedElement"
                 "org.rust.lang.core.psi.RustItemElement"
                 "org.rust.lang.core.psi.RustMod"
                 "org.rust.lang.core.psi.RustInnerAttributeOwner" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RustModItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RustModItemElementStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

foreign_mod_item ::= attrs_and_vis extern_abi '{' inner_attr* foreign_decl* '}' {
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.RustItemElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RustForeignModItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RustForeignModItemElementStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private foreign_decl ::= constant | foreign_fn_decl


///////////////////////////////////////////////////////////////////////////////////////////////////
// Struct & Enums
///////////////////////////////////////////////////////////////////////////////////////////////////

struct_item ::= attrs_and_vis STRUCT IDENTIFIER generic_params? (tuple_fields? where_clause? ';' | where_clause? block_fields) {
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.RustStructOrEnumItemElement"
                 "org.rust.lang.core.psi.RustFieldsOwner" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RustStructItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RustStructItemElementStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

// RFC 1444
union_item ::= attrs_and_vis UNION IDENTIFIER generic_params? where_clause? block_fields {
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.RustItemElement"
                 "org.rust.lang.core.psi.RustQualifiedNameOwner"
                 "org.rust.lang.core.psi.RustGenericDeclaration" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RustUnionItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RustUnionItemElementStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

enum_item ::= attrs_and_vis ENUM IDENTIFIER generic_params? where_clause? enum_body {
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = "org.rust.lang.core.psi.RustStructOrEnumItemElement"
  mixin = "org.rust.lang.core.psi.impl.mixin.RustEnumItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RustEnumItemElementStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

enum_body ::= '{' [ <<comma_separated_list enum_variant>> ] '}' {
  pin = 1
  extends = "org.rust.lang.core.psi.impl.RustStubbedElementImpl.WithParent<?>"
  stubClass = "org.rust.lang.core.stubs.RustEnumBodyElementStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
enum_variant ::= outer_attr* IDENTIFIER variant_args? {
  pin = 2
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.RustQualifiedNameOwner"
                 "org.rust.lang.core.psi.RustNamedElement"
                 "org.rust.lang.core.psi.RustOuterAttributeOwner"
                 "org.rust.lang.core.psi.RustFieldsOwner" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RustEnumVariantImplMixin"
  stubClass = "org.rust.lang.core.stubs.RustEnumVariantElementStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private variant_args ::= variant_block_fields
                       | variant_tuple_fields
                       | variant_discriminant

block_fields ::= <<mk_block_fileds field_decl>> {
  extends = "org.rust.lang.core.psi.impl.RustStubbedElementImpl.WithParent<?>"
  stubClass = "org.rust.lang.core.stubs.RustBlockFieldsElementStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
tuple_fields ::= <<mk_tuple_fields tuple_field_decl>>

variant_block_fields ::= <<mk_block_fileds variant_field_decl>> { elementType = block_fields }
variant_tuple_fields ::= <<mk_tuple_fields variant_tuple_field_decl>> { elementType = tuple_fields }

variant_discriminant ::= '=' any_expr { pin = 1 }

field_decl ::= attrs_and_vis IDENTIFIER type_ascription {
  pin = 2
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.RustOuterAttributeOwner"
                 "org.rust.lang.core.psi.RustVisibilityOwner"
                 "org.rust.lang.core.psi.RustTupleOrStructFieldDeclElement"
                 "org.rust.lang.core.psi.RustNamedElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RustFieldDeclImplMixin"
  stubClass = "org.rust.lang.core.stubs.RustFieldDeclElementStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}
// unlike structs, enum variants can't have `pub` visibility applied to fields
variant_field_decl ::= outer_attr* IDENTIFIER type_ascription {
  pin = 2
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  elementType = field_decl
}

tuple_field_decl ::= attrs_and_vis type {
  implements = [ "org.rust.lang.core.psi.RustOuterAttributeOwner"
                 "org.rust.lang.core.psi.RustVisibilityOwner"
                 "org.rust.lang.core.psi.RustTupleOrStructFieldDeclElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RustTupleFieldDeclImplMixin"
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
}
variant_tuple_field_decl ::= outer_attr* type {
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  elementType = tuple_field_decl
}

private meta mk_block_fileds ::= '{' <<field_with_recover <<param>> >>* '}' { pin = 1}
private meta field_with_recover ::= !'}' <<param>> (',' | &'}') {
  pin = 1
  recoverWhile = field_recover
}
private field_recover ::= !('}' | '#' | PUB | IDENTIFIER)

private meta mk_tuple_fields ::= '(' <<comma_separated_list <<param>> >> ')' { pin = 1}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Trait
///////////////////////////////////////////////////////////////////////////////////////////////////

trait_item ::= attrs_and_vis UNSAFE? TRAIT IDENTIFIER generic_params? type_param_bounds? where_clause? trait_body {
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.RustQualifiedNameOwner"
                 "org.rust.lang.core.psi.RustTypeBearingItemElement"
                 "org.rust.lang.core.psi.RustGenericDeclaration" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RustTraitItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RustTraitItemElementStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private trait_body ::= '{' trait_member* '}' { pin = 1 }

// TODO: use upper rules and inheritance here
private trait_member ::= !'}' ( constant | trait_type_member | trait_method_member ) {
  pin = 1
  recoverWhile = trait_member_recover
}

private trait_member_recover ::= !('#' | vis | EXTERN | CONST | UNSAFE | FN | TYPE_KW | '}')


///////////////////////////////////////////////////////////////////////////////////////////////////
// Impl
///////////////////////////////////////////////////////////////////////////////////////////////////

impl_item ::= attrs_and_vis UNSAFE? IMPL generic_params? (for_impl | bare_impl) {
  pin = "IMPL"
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  implements = [ "org.rust.lang.core.psi.RustItemElement"
                 "org.rust.lang.core.psi.RustGenericDeclaration" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RustImplItemImplMixin"
  stubClass = "org.rust.lang.core.stubs.RustImplItemElementStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

private bare_impl ::= type !FOR where_clause? impl_body { pin = 2 }
private for_impl ::= '!'? trait_ref FOR (auto_trait_impl | type_trait_impl) { pin = 3 }
private auto_trait_impl ::= '..' '{' '}' { pin = 1 }
private type_trait_impl ::= type where_clause? impl_body { pin = 1 }

private impl_body ::= '{' inner_attr* impl_member* '}' { pin = 1 }

// TODO: unify with trait_member?
private impl_member ::= !'}' ( impl_method_member | constant | impl_macro_member | impl_type_member ) {
  pin = 1
  recoverWhile = impl_member_recover
}
private impl_member_recover ::= !('#' | vis | EXTERN | CONST | UNSAFE | FN | (IDENTIFIER '!') | TYPE_KW | "default" | '}')


///////////////////////////////////////////////////////////////////////////////////////////////////
// Types
///////////////////////////////////////////////////////////////////////////////////////////////////

private type_ascription ::= ':' type

type ::= vec_type
       | ptr_type
       | ref_type
       | bare_fn_type
       | tuple_type
       | path_type
       | type_with_bounds_type
       | for_in_type
       | impl_trait_type
       | wildcard_type
       | never_type

vec_type ::= '[' type [';' any_expr] ']'

ptr_type ::= '*' [ MUT | CONST ] type

ref_type ::= '&' [ LIFETIME? MUT? ] type

bare_fn_type ::= [ UNSAFE? extern_abi? ] FN fn_type_parameters ret_type?

tuple_type ::= '(' [ <<comma_separated_list type>> ] ')'

path_type ::= !'<' path_generic_args_without_colons
            | &'<' type_qual_path

type_with_bounds_type ::= type ('+' bound) +
bound ::= LIFETIME | trait_ref

for_in_type ::= for_lifetimes (bare_fn_type | trait_ref)

impl_trait_type ::= IMPL polybound ('+' polybound)*

wildcard_type ::= '_'
never_type ::= '!'

fake type_alias ::=
  outer_attr* DEFAULT? vis? TYPE_KW IDENTIFIER ( generic_params where_clause? | where_clause | type_param_bounds )? [ '=' type ] ';'
{
  pin = 'IDENTIFIER'
  implements = [ "org.rust.lang.core.psi.RustQualifiedNameOwner"
                 "org.rust.lang.core.psi.RustTypeBearingItemElement"
                 "org.rust.lang.core.psi.RustGenericDeclaration" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RustTypeAliasImplMixin"
  stubClass = "org.rust.lang.core.stubs.RustTypeAliasElementStub"
  elementTypeFactory = "org.rust.lang.core.stubs.StubImplementationsKt.factory"
}

type_item ::=
  outer_attr*          vis? TYPE_KW IDENTIFIER generic_params? where_clause? '=' type ';'
{
  pin = 'IDENTIFIER'
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  elementType = type_alias
}

trait_type_member ::=
  outer_attr*               TYPE_KW IDENTIFIER type_param_bounds? [ '=' type ] ';'
{
  pin = 'IDENTIFIER'
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  elementType = type_alias
}

impl_type_member ::=
  outer_attr* DEFAULT? vis? TYPE_KW IDENTIFIER generic_params? '=' type ';'
{
  pin = 'IDENTIFIER'
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
  elementType = type_alias
}

type_qual_path ::= <<qualified_path path_without_types>>

///////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////////////////////////

// https://doc.rust-lang.org/reference.html#operator-precedence
// https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md#24-compact-expression-parsing-with-priorities
//
// Rust expression grammar allows or forbids struct literals depending on context.
// There are `no_struct_lit_expr` and `any_expr` productions for this two cases.
// `expr` production is an implementation detail. It passes the context information to the child expressions.
expr ::= ret_expr
       | lambda_expr
       | assign_bin_expr
       | block_expr
       | cont_expr
       | break_expr
       | full_range_expr
       | open_range_expr
       | bool_or_bin_expr
       | bool_and_bin_expr
       | comp_bin_expr
       | rel_comp_bin_expr
       | bit_or_bin_expr
       | bit_xor_bin_expr
       | bit_and_bin_expr
       | bit_shift_bin_expr
       | add_bin_expr
       | mul_bin_expr
       | cast_expr
       | unary_expr
       | try_expr
       | atom_expr

// https://github.com/rust-lang/rfcs/blob/master/text/0092-struct-grammar.md
no_struct_lit_expr ::= <<structLiterals 'OFF' expr>> { elementType = expr }
any_expr ::= <<structLiterals 'ON' <<stmtMode 'OFF' expr>> >> { elementType = expr }
stmt_mode_expr ::= <<structLiterals 'ON' <<stmtMode 'ON' expr>> >> { elementType = expr }
stmt_mode_expr_off ::= <<stmtMode 'OFF' expr>> { elementType = expr }


block_expr ::= while_expr
             | if_expr
             | for_expr
             | loop_expr
             | match_expr
             | (UNSAFE &'{')? simple_block


private atom_expr ::= lit_expr
                    | macro_expr
                    | struct_expr
                    | qual_path_expr
                    | method_call_expr
                    | field_expr
                    | index_expr
                    | path_expr !'('
                    | call_expr
                    | array_expr
                    | unit_expr
                    | tuple_or_paren_expr


fake binary_expr ::= expr+ {
  methods=[
    left="/expr[0]"
    right="/expr[1]"
  ]
}

assign_bin_expr ::= expr
                  ( gtgteq
                  | ltlteq
                  | '|='
                  | '^='
                  | '&='
                  | '='
                  | '+='
                  | '-='
                  | '*='
                  | '/='
                  | '%='
                  ) expr    { rightAssociative = true }

comp_bin_expr       ::= expr !<<isCompleteBlockExpr>> ('==' | '!=') stmt_mode_expr_off
rel_comp_bin_expr   ::= expr !<<isCompleteBlockExpr>> ('<' !('<' | '=') | '>' !('>' | '=') | lteq | gteq) stmt_mode_expr_off
bit_shift_bin_expr  ::= expr !<<isCompleteBlockExpr>> (ltlt | gtgt) stmt_mode_expr_off
add_bin_expr        ::= expr !<<isCompleteBlockExpr>> ('+' | '-') stmt_mode_expr_off
mul_bin_expr        ::= expr !<<isCompleteBlockExpr>> ('*' | '/' | '%') stmt_mode_expr_off

// <expr> | <expr> has higher priority than <expr> || <expr>
bool_or_bin_expr    ::= expr !<<isCompleteBlockExpr>> oror stmt_mode_expr_off
bool_and_bin_expr   ::= expr !<<isCompleteBlockExpr>> andand stmt_mode_expr_off
bit_or_bin_expr     ::= expr !(<<isCompleteBlockExpr>> | oror)   '|' stmt_mode_expr_off
bit_and_bin_expr    ::= expr !(<<isCompleteBlockExpr>> | andand) '&' stmt_mode_expr_off
bit_xor_bin_expr    ::= expr !<<isCompleteBlockExpr>> '^' stmt_mode_expr_off


cast_expr ::= expr AS type

try_expr ::= expr '?'

unary_expr ::= (BOX | '-' | '*' | '!' | '&' MUT?) expr

lambda_expr ::= MOVE? lambda_parameters ret_type? any_expr

struct_expr ::= <<checkStructAllowed>> path_generic_args_with_colons struct_expr_body

struct_expr_body ::= '{' [ <<comma_separated_list struct_expr_field>> ] ('..'  any_expr)? '}' {
  pin = 1
}

struct_expr_field ::= IDENTIFIER ':' any_expr {
  pin = 1
  recoverWhile = struct_expr_field_recover
  implements = [ "org.rust.lang.core.psi.RustReferenceElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RustStructExprFieldImplMixin"
}
private struct_expr_field_recover ::= !(IDENTIFIER | ',' | '}' | '..')

path_expr ::= path_generic_args_with_colons

qual_path_expr ::= << qualified_path path_generic_args_with_colons >>

while_expr ::= label? WHILE condition simple_block { pin = 'WHILE' }
condition ::= (LET pat '=')? no_struct_lit_expr

loop_expr ::= label? LOOP simple_block { pin = 'LOOP' }
private label ::= LIFETIME ':'

cont_expr ::= CONTINUE LIFETIME?

break_expr ::= BREAK LIFETIME?

for_expr ::= label? FOR pat IN no_struct_lit_expr simple_block { pin = "FOR" }

match_expr ::= MATCH no_struct_lit_expr match_body { pin = 'MATCH'}
match_body ::= '{' match_arm* '}' { pin = 1 }
match_arm ::= outer_attr* match_pat '=>' stmt_mode_expr (',' | (&'}' | <<isBlock>>)) {
  pin = 2
  recoverWhile = match_arm_recover
}
private match_arm_recover ::= !(first_pat | first_outer_attr | '}')
match_pat ::= pat ('|' pat)* (IF any_expr)?

if_expr ::= IF condition simple_block else_branch? { pin = 'IF' }
else_branch ::= ELSE ( if_expr | simple_block )

ret_expr ::= RETURN expr?

unit_expr ::= '(' ')'

// It is possible to distinguish between paren_expr (any_expr) and a single element
// tuple_expr (any_expr,) only after almost all input has been consumed. That is, it's
// not LL(k) for any k. So let's use a custom rule to avoid exponential backtracking.
tuple_or_paren_expr ::= << tupleOrParenExpr any_expr tuple_expr_end paren_expr_end >>

// Used by `tupleOrParenExpr`
tuple_expr ::= '(' any_expr tuple_expr_end
private tuple_expr_end ::= ',' [ any_expr (',' any_expr)* ','? ] ')'

// Used by `tupleOrParenExpr`
paren_expr ::= '(' any_expr paren_expr_end
private paren_expr_end ::= ')'

array_expr ::= '[' array_initializer ']' { pin = 1 }
private array_initializer ::= [ any_expr ( ';' any_expr | (',' any_expr)* ','? ) ]


//private range_expr_group ::= open_range_expr
//                           | full_range_expr

full_range_expr ::= expr ( '..' (&<<checkBraceAllowed>> expr)? | '...' (&<<checkBraceAllowed>> expr) )
open_range_expr ::=      ( '..' (&<<checkBraceAllowed>> expr)? | '...' (&<<checkBraceAllowed>> expr) )

fake range_expr ::= expr + {
  methods=[
    from="/expr[0]"
    to="/expr[1]"
  ]
}


index_expr ::= expr index_arg
// Do not inline this rule, it breaks expression parsing
private index_arg ::= '[' expr ']'

call_expr ::= expr !<<isCompleteBlockExpr>> arg_list

method_call_expr ::= expr '.' IDENTIFIER colon_generic_args? arg_list {
  implements = [ "org.rust.lang.core.psi.RustReferenceElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RustMethodCallExprImplMixin"
}

arg_list ::= '(' expr_list? ')' { pin = 1 }

private expr_list ::= <<comma_separated_list any_expr>>

field_id ::= IDENTIFIER | INTEGER_LITERAL

field_expr ::= expr '.' field_id {
  implements = [ "org.rust.lang.core.psi.RustReferenceElement" ]
  mixin = "org.rust.lang.core.psi.impl.mixin.RustFieldExprImplMixin"
}

lit_expr ::= lit


///////////////////////////////////////////////////////////////////////////////////////////////////
// Macros
///////////////////////////////////////////////////////////////////////////////////////////////////

fake macro ::= macro_invocation macro_arg?

// Various kinds of macros
expr_like_macro ::= macro_invocation macro_arg
item_like_macro ::= macro_invocation item_macro_arg

try_macro ::= try_macro_invocation try_macro_args { pin = 1 }
format_like_macro ::= format_like_macro_invocation format_macro_args { pin = 1 }
assert_macro ::= assert_macro_invocation assert_macro_args { pin = 1 }
assert_eq_macro ::= assert_eq_macro_invocation assert_eq_macro_args { pin = 1 }

vec_macro ::= vec_macro_invocation vec_macro_args { pin = 1 }
log_macro ::= log_macro_invocation log_macro_args { pin = 1 }

macro_definition ::= macro_rules_invocation IDENTIFIER item_macro_arg {
  pin = 1
  extends = item_like_macro
}

private build_in_macro ::= try_macro
                         | format_like_macro
                         | assert_macro
                         | assert_eq_macro
                         | vec_macro
                         | log_macro

private zz_macro_call ::= build_in_macro | expr_like_macro { pin(".*") = macro_invocation }
private zz_macro_item ::= macro_definition | item_like_macro {
  pin(".*") = macro_invocation
  hooks = [ leftBinder = "DOC_COMMENT_BINDER" ]
}

// Invocations
macro_invocation ::= IDENTIFIER '!' IDENTIFIER?
try_macro_invocation ::= "try" '!'
vec_macro_invocation ::= "vec" '!'
log_macro_invocation ::= ( "trace" | "log" | "warn" | "debug" | "error" | "info" ) '!'
macro_rules_invocation ::= "macro_rules" '!'

// https://doc.rust-lang.org/std/fmt/
format_like_macro_invocation ::= ( "format"
                                 | "format_args"
                                 | "write"
                                 | "writeln"
                                 | "print"
                                 | "println"
                                 | "panic") '!'

assert_macro_invocation ::= ( "assert"
                            | "debug_assert") '!'

assert_eq_macro_invocation ::= ( "assert_eq"
                               | "assert_ne"
                               | "debug_assert_eq"
                               | "debug_assert_ne") '!'

// Arguments
macro_arg ::= <<macro_args_delim token_trees>>

item_macro_arg ::= '(' token_trees ')' ';'
                 | '{' token_trees '}'
                 | '[' token_trees ']' ';' {
  pin = 1
  elementType = macro_arg
}

try_macro_args ::= <<macro_args_delim any_expr>>
vec_macro_args ::= '[' array_initializer ']'  { pin = 1 }

private zz_log_macro_args ::= ('target' ':' expr ','?)? (<<comma_separated_list format_macro_arg>>)?
log_macro_args ::=  <<macro_args_delim zz_log_macro_args>>

private zz_assert_macro_args ::= any_expr [ ',' <<comma_separated_list format_macro_arg>> ]
assert_macro_args ::= <<macro_args_delim zz_assert_macro_args>>

private zz_assert_eq_macro_args ::= any_expr ',' any_expr [ ',' <<comma_separated_list format_macro_arg>> ]
assert_eq_macro_args ::= <<macro_args_delim zz_assert_eq_macro_args>>

format_macro_args ::= <<macro_args_delim [ <<comma_separated_list format_macro_arg>> ] >>
format_macro_arg ::= [ IDENTIFIER '=' ] any_expr

private meta macro_args_delim ::= '(' <<param>> ')'
                                | '{' <<param>> '}'
                                | '[' <<param>> ']' { pin = 1 }

// Macro wrappers
macro_expr ::= zz_macro_call
pat_macro  ::= zz_macro_call
// TODO: Maybe implement item-related stuff for this production?
macro_item ::= attrs_and_vis zz_macro_item {
    implements = [ "org.rust.lang.core.psi.RustOuterAttributeOwner" ]
}
impl_macro_member ::= zz_macro_item

// Utils
private token_trees ::= token_tree*

token_tree ::= '(' token_trees ')'
             | '{' token_trees '}'
             | '[' token_trees ']'
             | << unpairedToken >> +


///////////////////////////////////////////////////////////////////////////////////////////////////
// Literals
///////////////////////////////////////////////////////////////////////////////////////////////////

private lit ::= ( STRING_LITERAL
                | CHAR_LITERAL
                | BYTE_STRING_LITERAL
                | BYTE_LITERAL
                | RAW_STRING_LITERAL
                | RAW_BYTE_STRING_LITERAL
                | INTEGER_LITERAL
                | FLOAT_LITERAL
                | FALSE | TRUE )


///////////////////////////////////////////////////////////////////////////////////////////////////
// Statements
///////////////////////////////////////////////////////////////////////////////////////////////////

fake block ::= '{' inner_attr* (item | stmt)* expr? '}' {
  pin = 1
  implements = "org.rust.lang.core.psi.RustItemsOwner"
}

simple_block ::= '{' block_tail '}' {
  pin = 1
  elementType = block
}

inner_attrs_and_block ::= '{' inner_attr* block_tail '}' {
  pin = 1
  elementType = block
}

private block_tail ::= (expr_stmt_or_last_expr | stmt | item)* { recoverWhile = block_recover }
private block_recover ::= !('}')

stmt ::= let_decl | empty_stmt | never ';'

expr_stmt_or_last_expr ::= outer_attr? stmt_mode_expr (expr_stmt_upper | last_expr_upper)

upper expr_stmt_upper ::= ';' | () <<isBlock>> !('}') { elementType = expr_stmt }
upper last_expr_upper ::= () &'}' { elementType = expr pin = 1 }

fake expr_stmt ::= outer_attr? any_expr ';'? { extends = stmt }

let_decl ::= outer_attr? LET pat type_ascription? [ '=' any_expr ] ';' {
  extends = stmt
  pin = "LET"
}

empty_stmt ::= ';' {
  extends = stmt
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Utils
///////////////////////////////////////////////////////////////////////////////////////////////////

private gtgteq ::= <<gtgteqImpl>>  | never GTGTEQ { name = ">>=" }
private gtgt   ::= <<gtgtImpl>>    | never GTGT   { name = ">>" }
private gteq   ::= <<gteqImpl>>    | never GTEQ   { name = ">=" }
private ltlteq ::= <<ltlteqImpl>>  | never LTLTEQ { name = "<<=" }
private ltlt   ::= <<ltltImpl>>    | never LTLT   { name = "<<" }
private lteq   ::= <<lteqImpl>>    | never LTEQ   { name = "<=" }
private oror   ::= <<ororImpl>>    | never OROR   { name = "||" }
private andand ::= <<andandImpl>>  | never ANDAND { name = "&&" }

private never ::= !()

// Trailing commas are allowed
private meta comma_separated_list ::= <<param>> ( ',' <<param>> )* ','?
private meta list_element ::= <<param>> (',' | &'>') { pin = 1 }
