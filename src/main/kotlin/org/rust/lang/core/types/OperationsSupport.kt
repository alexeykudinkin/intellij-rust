package org.rust.lang.core.types

import org.rust.lang.core.psi.*
import org.rust.lang.core.resolve.indexes.RsImplIndex
import org.rust.lang.core.types.types.*


fun RsExpr.findImpl(traitName: String): RsImplItem? {
    val traitImpls = RsImplIndex.findImplsFor(type, project)
        .filter { it.traitRef?.text == traitName } // may be not from ops.rs
        .distinct() // somehow here can be more than one same impl
    if (traitImpls.toList().size != 1) {
        return null
    } else {
        return traitImpls.first()
    }
}

fun inferTypeWithOutput(expr: RsBinaryExpr, traitName: String): RustType {
    val left = expr.left.type
    val right = expr.right?.type
    if (left.isPrimitive) {
        val primitive = tryInferPrimitive(left as RustPrimitiveType, right)
        if (primitive != null) {
            return primitive
        }
    }
    val traitImpl = expr.left.findImpl(traitName) ?: return RustUnknownType

    val outputTypeAlias = traitImpl.typeAliasList.find { it.name == "Output" }
    return outputTypeAlias?.typeReference?.type ?: RustUnknownType
}


//primitive type implementations are generated by macros, using fallback
private fun tryInferPrimitive(left: RustPrimitiveType, right: RustType?): RustType? {
    right ?: return RustUnknownType
    when (left) {
        is RustIntegerType -> {
            if (right is RustIntegerType && right.kind == left.kind) {
                return RustIntegerType(left.kind)
            }
        }
        is RustFloatType -> {
            if (right is RustFloatType && right.kind == left.kind) {
                return RustFloatType(left.kind)
            }
        }
    }
    return null
}


