{
    parserClass='org.rust.lang.core.parser.RustParser'
    parserUtilClass="org.rust.lang.core.parser.RustParserUtil"

    implements='org.rust.lang.core.psi.RustCompositeElement'
    extends='org.rust.lang.core.psi.impl.RustCompositeElementImpl'

    elementTypeHolderClass='org.rust.lang.core.psi.RustCompositeElementTypes'

    elementTypeClass='org.rust.lang.core.psi.RustCompositeElementType'
    tokenTypeClass='org.rust.lang.core.psi.RustTokenType'

    psiClassPrefix='Rust'
    psiImplClassSuffix='Impl'
    psiPackage='org.rust.lang.core.psi'
    psiImplPackage='org.rust.lang.core.psi.impl'

    parserImports='static org.rust.lang.core.psi.RustTokenElementTypes.*'


    tokens = [
        LBRACE               =  '{'
        RBRACE               =  '}'
        LBRACK               =  '['
        RBRACK               =  ']'
        LPAREN               =  '('
        RPAREN               =  ')'
        COLON                =  ':'
        COLONCOLON           =  '::'
        SEMICOLON            =  ';'
        COMMA                =  ','
        EQ                   =  '='
        EXCLEQ               =  '!='
        EQEQ                 =  '=='
        SHA                  =  '#'
        EXCL                 =  '!'
        PLUSEQ               =  '+='
        PLUS                 =  '+'
        MINUSEQ              =  '-='
        MINUS                =  '-'
        OROR                 =  '||'
        OREQ                 =  '|='
        ANDAND               =  '&&'
        ANDEQ                =  '&='
        AND                  =  '&'
        OR                   =  '|'
        LT                   =  '<'
        XOREQ                =  '^='
        XOR                  =  '^'
        MULEQ                =  '*='
        MUL                  =  '*'
        DIVEQ                =  '/='
        DIV                  =  '/'
        REMEQ                =  '%='
        REM                  =  '%'
        GT                   =  '>'
        DOT                  =  '.'
        DOTDOT               =  '..'
        DOTDOTDOT            =  '...'
        FAT_ARROW            =  '=>'
        ARROW                =  '->'
        Q                    =  '?'
        AT                   =  '@'
        UNDERSCORE           =  '_'

        // DEBUG

        ABSTRACT  = 'abstract'
        ALIGNOF   = 'alignof'
        AS        = 'as'
        BECOME    = 'become'
        BOX       = 'box'
        BREAK     = 'break'
        CONST     = 'const'
        CONTINUE  = 'continue'
        CRATE     = 'crate'
        DO        = 'do'
        ELSE      = 'else'
        ENUM      = 'enum'
        EXTERN    = 'extern'
        FALSE     = 'false'
        FINAL     = 'final'
        FN        = 'fn'
        FOR       = 'for'
        IF        = 'if'
        IMPL      = 'impl'
        IN        = 'in'
        LET       = 'let'
        LOOP      = 'loop'
        MACRO     = 'macro'
        MATCH     = 'match'
        MOD       = 'mod'
        MOVE      = 'move'
        MUT       = 'mut'
        OFFSETOF  = 'offsetof'
        OVERRIDE  = 'override'
        PRIV      = 'priv'
        PROC      = 'proc'
        PUB       = 'pub'
        PURE      = 'pure'
        REF       = 'ref'
        RETURN    = 'return'
        CSELF     = 'Self'
        SELF      = 'self'
        SIZEOF    = 'sizeof'
        STATIC    = 'static'
        STRUCT    = 'struct'
        SUPER     = 'super'
        TRAIT     = 'trait'
        TRUE      = 'true'
        TYPE_KW   = 'type'
        TYPEOF    = 'typeof'
        UNSAFE    = 'unsafe'
        UNSIZED   = 'unsized'
        USE       = 'use'
        VIRTUAL   = 'virtual'
        WHERE     = 'where'
        WHILE     = 'while'
        YIELD     = 'yield'

        SHEBANG_LINE = '#!/bin/bash'

        // _DBG
        identifier  = 'regexp:\p{Alpha}\w*'
        space       = 'regexp:\s+'
    ]

    //
    // Mixins
    //

    mixin       ("trait_item") = "org.rust.lang.core.psi.impl.mixin.RustTraitItemImplMixin"

    mixin       ("impl_item")  = "org.rust.lang.core.psi.impl.mixin.RustImplItemImplMixin"

    mixin       ("struct_item") = "org.rust.lang.core.psi.impl.mixin.RustStructItemImplMixin"

    mixin       ("struct_decl_field") = "org.rust.lang.core.psi.impl.mixin.RustStructDeclFieldImplMixin"

    mixin       ("mod_decl_item") = "org.rust.lang.core.psi.impl.mixin.RustModDeclItemImplMixin"

    mixin       ("const_item") = "org.rust.lang.core.psi.impl.mixin.RustConstItemImplMixin"

    mixin       ("extern_crate_item") = "org.rust.lang.core.psi.impl.mixin.RustExternCrateItemImplMixin"

    mixin       ("foreign_mod_item") = "org.rust.lang.core.psi.impl.mixin.RustForeignModItemImplMixin"

    mixin       ("static_item") = "org.rust.lang.core.psi.impl.mixin.RustStaticItemImplMixin"

    mixin       ("type_item") = "org.rust.lang.core.psi.impl.mixin.RustTypeItemImplMixin"

    mixin       ("use_item") = "org.rust.lang.core.psi.impl.mixin.RustUseItemImplMixin"

    mixin       ("struct_tuple_field") = "org.rust.lang.core.psi.impl.mixin.RustStructTupleFieldImplMixin"


    //
    // References
    //

    mixin       ("path_part") = "org.rust.lang.core.psi.impl.mixin.RustPathPartImplMixin"
    implements  ("path_part") = "org.rust.lang.core.psi.RustQualifiedReferenceElement"

    //
    // Resolve scopes
    //

    implements  ("file_mod_item") = "org.rust.lang.core.resolve.scope.RustResolveScope"
    mixin       ("file_mod_item") = "org.rust.lang.core.psi.impl.mixin.RustFileModItemImplMixin"

    implements  ("mod_item") = "org.rust.lang.core.resolve.scope.RustResolveScope"
    mixin       ("mod_item") = "org.rust.lang.core.psi.impl.mixin.RustModItemImplMixin"

    implements  ("fn_item") = "org.rust.lang.core.resolve.scope.RustResolveScope"
    mixin       ("fn_item") = "org.rust.lang.core.psi.impl.mixin.RustFnItemImplMixin"

    implements  ("enum_item") = "org.rust.lang.core.resolve.scope.RustResolveScope"
    mixin       ("enum_item") = "org.rust.lang.core.psi.impl.mixin.RustEnumItemImplMixin"

    implements  ("trait_method_member") = "org.rust.lang.core.resolve.scope.RustResolveScope"
    mixin       ("trait_method_member") = "org.rust.lang.core.psi.impl.mixin.RustTraitMethodMemberImplMixin"

    implements  ("lambda_expr") = "org.rust.lang.core.resolve.scope.RustResolveScope"
    mixin       ("lambda_expr") = "org.rust.lang.core.psi.impl.mixin.RustLambdaExprImplMixin"

    implements  ("impl_method_member") = [ "org.rust.lang.core.resolve.scope.RustResolveScope"
                                           "org.rust.lang.core.psi.RustAccessControlElement" ]
    mixin       ("impl_method_member") = "org.rust.lang.core.psi.impl.mixin.RustImplMethodImplMixinMember"

    implements  ("block") =  "org.rust.lang.core.resolve.scope.RustResolveScope"
    mixin       ("block") =  "org.rust.lang.core.psi.impl.mixin.RustBlockImplMixin"

    implements  ("scoped_let_expr") = "org.rust.lang.core.resolve.scope.RustResolveScope"
    mixin       ("scoped_let_expr") = "org.rust.lang.core.psi.impl.mixin.RustScopedLetExprImplMixin"

    implements  ("for_expr") = "org.rust.lang.core.resolve.scope.RustResolveScope"
    mixin       ("for_expr") = "org.rust.lang.core.psi.impl.mixin.RustForExprImplMixin"

    implements  ("match_arm") = "org.rust.lang.core.resolve.scope.RustResolveScope"
    mixin       ("match_arm") = "org.rust.lang.core.psi.impl.mixin.RustMatchArmImplMixin"


    //
    // Declaring elements
    //

    implements  ("enum_variant")    = [ "org.rust.lang.core.psi.RustDeclaringElement"
                                        "org.rust.lang.core.psi.RustNamedElement" ]
    mixin       ("enum_variant")    = "org.rust.lang.core.psi.impl.mixin.RustEnumVariantImplMixin"

    implements  ("let_decl")    = "org.rust.lang.core.psi.RustDeclaringElement"
    mixin       ("let_decl")    = "org.rust.lang.core.psi.impl.mixin.RustLetDeclImplMixin"

    implements  ("scoped_let_decl") = "org.rust.lang.core.psi.RustDeclaringElement"
    mixin       ("scoped_let_decl") = "org.rust.lang.core.psi.impl.mixin.RustScopedLetDeclImplMixin"

    implements  ("scoped_for_decl") = "org.rust.lang.core.psi.RustDeclaringElement"
    mixin       ("scoped_for_decl") = "org.rust.lang.core.psi.impl.mixin.RustScopedForDeclImplMixin"

    implements  ("param")       = "org.rust.lang.core.psi.RustDeclaringElement"
    mixin       ("param")       = "org.rust.lang.core.psi.impl.mixin.RustParamImplMixin"

    implements  ("anon_param")  = "org.rust.lang.core.psi.RustDeclaringElement"
    mixin       ("anon_param")  = "org.rust.lang.core.psi.impl.mixin.RustAnonParamImplMixin"

    implements  ("lambda_param")  = "org.rust.lang.core.psi.RustDeclaringElement"
    mixin       ("lambda_param")  = "org.rust.lang.core.psi.impl.mixin.RustLambdaParamImplMixin"

    implements  ("match_pat")   = "org.rust.lang.core.psi.RustDeclaringElement"
    mixin       ("match_pat")   = "org.rust.lang.core.psi.impl.mixin.RustMatchPatImplMixin"

    implements  ("pat_binding") = [ "org.rust.lang.core.psi.RustDeclaringElement"
                                    "org.rust.lang.core.psi.RustNamedElement" ]
    mixin       ("pat_binding") = "org.rust.lang.core.psi.impl.mixin.RustPatBindingImplMixin"

    //
    // AccessControl
    //

    implements("struct_decl_field")  = "org.rust.lang.core.psi.RustAccessControlElement"
    implements("struct_tuple_field") = "org.rust.lang.core.psi.RustAccessControlElement"

    //
    //  Misc
    //

    implements  ("alias") = "org.rust.lang.core.psi.RustNamedElement"
    extends     ("alias") = "org.rust.lang.core.psi.impl.RustNamedElementImpl"

    implements  ("self_argument") = [ "org.rust.lang.core.psi.RustNamedElement"
                                      "org.rust.lang.core.psi.RustDeclaringElement" ]
    mixin       ("self_argument") = "org.rust.lang.core.psi.impl.mixin.RustSelfArgumentImplMixin"

    implements  ("use_glob") = "org.rust.lang.core.psi.RustNamedElement"
    mixin       ("use_glob") = "org.rust.lang.core.psi.impl.mixin.RustUseGlobImplMixin"

    elementType(".*_bin_expr")   = binary_expr
    elementType(".*_range_expr") = range_expr

    extends           ("(?!meta_item)(?!foreign_item).*_item") = item_
    elementTypeFactory("(?!meta_item)(?!foreign_item).*_item") = "org.rust.lang.core.stubs.types.ElementFactoryKt.factory"
    stubClass         ("(?!meta_item)(?!foreign_item).*_item") = "org.rust.lang.core.stubs.RustItemStub"


    extends("(if|while)_let_expr") = scoped_let_expr
    extends(".*_expr") = restricted_expr
    extends("(?!ret_type).*_type") = type
    extends(".*_stmt") = stmt
    extends("pat_.*")  = pat
    extends(".*_attr") = attr
    extends("inner_attrs_and_block") = block

    generateTokens=false
    generateTokenAccessors=true

    consumeTokenMethod(".*") = "consumeTokenFast"

    //recoverWhile = skip_until_eol_rec
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Root
///////////////////////////////////////////////////////////////////////////////////////////////////

root ::= file_mod_item

//
// NOTA BENE
//  Its marked left just to impede GK from collapsing it in the
//  case there're no `SHEBANG_LINE` & it starts with `inner_attrs` or `item`
//
left file_mod_item ::= [ SHEBANG_LINE ] inner_attr* item * {
  extends = mod_item
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Attributes
///////////////////////////////////////////////////////////////////////////////////////////////////

fake attr ::= meta_item

inner_attr ::= '#' '!' '[' meta_item ']' | INNER_DOC_COMMENT

outer_attr ::= '#' '[' meta_item ']' | OUTER_DOC_COMMENT

meta_item ::= IDENTIFIER [ '=' lit_expr | '(' [ <<comma_separated_list meta_item>> ] ')' ]


///////////////////////////////////////////////////////////////////////////////////////////////////
// Items
///////////////////////////////////////////////////////////////////////////////////////////////////

vis ::= PUB

private attrs_and_vis ::= outer_attr* vis?
private item_inner ::= stmt_item_group
                     | item_macro

//
// TODO(kudinkin): That's a hack to force GK to generate accessors
//                 for the items
//
// NOTA BENE: Naming is crucial
//
fake item_ ::= attrs_and_vis {
  implements  = [ "org.rust.lang.core.psi.RustDeclaringElement"
                  "org.rust.lang.core.psi.RustNamedElement"
                  "org.rust.lang.core.psi.RustAccessControlElement" ]
  mixin       = "org.rust.lang.core.psi.impl.mixin.RustItemImplMixin"
  stubClass   = "org.rust.lang.core.stubs.RustItemStub"
}

upper item ::= << injectInto attrs_and_vis item_inner >> {
  elementType = item_
}

private stmt_item_group ::= static_item
                          | const_item
                          | type_item
                          | block_item_group
                          | view_item


private block_item_group ::= &(CONST? UNSAFE? extern_abi? FN) fn_item
                           | &(UNSAFE? TRAIT ) trait_item
                           | &(UNSAFE? IMPL  ) impl_item
                           | mod_decl_item
                           | mod_item
                           | foreign_mod_item
                           | struct_item
                           | enum_item


///////////////////////////////////////////////////////////////////////////////////////////////////
// Functions
///////////////////////////////////////////////////////////////////////////////////////////////////

private fn_header ::= CONST? UNSAFE? extern_abi? FN IDENTIFIER

extern_abi ::= EXTERN STRING_LITERAL?

fn_params ::= '(' !',' params ','? ')' { pin(".*") = 1 }
private params ::= [ param (',' param)* ]
param ::= pat ':' type

ret_type ::= '->' (type | '!') { pin = 1 }

fn_item ::= fn_header generic_params fn_params ret_type? where_clause? inner_attrs_and_block {
   pin(".*") = 1
}

generic_params ::= [ generic_params_inner ]

private generic_params_inner ::= '<' lifetimes [ ',' [ type_params ','? ] ] '>'
                               | '<'                   type_params ','?     '>'
                               | '<' '>'

lifetimes ::= lifetime_and_bounds (',' lifetime_and_bounds)*

private lifetime_and_bounds ::= LIFETIME lifetime_bounds?
private lifetime_bounds     ::= ':' LIFETIME ('+' LIFETIME)*

private type_params ::= type_param (',' type_params)*

type_param ::= IDENTIFIER type_param_bounds? [ '=' type ]

type_param_bounds ::= ':' [ type_param_bound_seq ]

private type_param_bound_seq        ::= polybound type_param_bound_seq_right
private type_param_bound_seq_right  ::= [ '+' polybound type_param_bound_seq_right ]

polybound ::= [ FOR '<' lifetimes? '>' | '?' ] bound

where_clause ::= WHERE <<comma_separated_list where_pred>>

where_pred ::= for_lifetimes? (LIFETIME ':' [ LIFETIME ( '+' LIFETIME )* ] | type type_param_bounds)

for_lifetimes ::= FOR '<' lifetimes '>'

pat ::= pat_wild
      | pat_reg
      | pat_tup
      | pat_vec
      | pat_macro
      | pat_struct
      | pat_enum
      | pat_ident
      | pat_range
      | pat_uniq
      | pat_qual_path
   /* | SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident */

pat_qual_path   ::= << qualified_path path_without_types >>
pat_uniq        ::= BOX pat

// XXX(matklad): it is impossible to distinguish between nullary enum variants
// and identifiers during parsing.
//
//   match x {
//       None => { } // match enum variant
//       Name => { } // bind Name to x
//   }
pat_ident       ::= pat_binding [ '@' pat ]


pat_struct      ::= path_expr '{' pat_struct_fields '}'
pat_enum        ::= path_expr '(' ('..' | pat_tup_elts) ')'

pat_range ::= lit_or_path [ '...' lit_or_path ]

pat_tup ::= '(' [ pat_tup_elts ','? ] ')'
pat_vec ::= '[' pat_vec_elts ']'

private pat_tup_elts ::= pat (',' pat)*
private pat_vec_elts ::= [ pat_tup_elts ','? ] [ '..' [ ',' pat_tup_elts ','? ] ]

pat_reg ::= '&' MUT? pat
          | '&&' pat

pat_wild ::= '_'
pat_binding ::= binding_mode? IDENTIFIER !'...' !'::'

private lit_or_path ::= path_expr | lit | '-' lit

generic_args ::= '<' generic_values '>' {
  pin = "'<'"
}

private generic_values ::= lifetimes [ ',' type_sums_and_or_bindings ] ','?
                         |                 type_sums_and_or_bindings?

private type_sums_and_or_bindings ::=             bindings   ','?
                                    | types [ ',' bindings ] ','?

bindings ::= binding (',' binding)*
binding  ::= IDENTIFIER '=' type

pat_struct_fields ::= (pat_field ',')+ '..'
                    | <<comma_separated_list pat_field>>
                    | '..'

pat_field ::= IDENTIFIER ':' pat
            | BOX? pat_binding

binding_mode ::= REF MUT? | MUT

private static_decl ::= IDENTIFIER ':' type '=' any_expr

static_item ::= STATIC MUT? static_decl ';'
const_item ::= CONST static_decl ';'

private view_item ::= use_item
                    | extern_crate_item

use_item ::= USE view_path ';' { pin = 2 }

extern_crate_item ::= EXTERN CRATE IDENTIFIER alias? ';'

///////////////////////////////////////////////////////////////////////////////////////////////////
// Mods
///////////////////////////////////////////////////////////////////////////////////////////////////

mod_decl_item ::= MOD IDENTIFIER ';'

mod_item ::= MOD IDENTIFIER '{' inner_attr* item * '}' {
  pin(".*") = 3
}

foreign_mod_item ::= extern_abi '{' inner_attr* foreign_decl* '}'

foreign_decl  ::= attrs_and_vis ( foreign_static_decl | foreign_fn_decl ) ';'

foreign_static_decl ::= STATIC MUT? IDENTIFIER ':' type
foreign_fn_decl ::= FN IDENTIFIER generic_params fn_params_allow_variadic ret_type? where_clause?

private fn_params_allow_variadic ::= '(' params ',' '...' ')'
                                   | '(' params ',' ')'
                                   | '(' params ')'
                                   | '(' ')'


///////////////////////////////////////////////////////////////////////////////////////////////////
// Struct
///////////////////////////////////////////////////////////////////////////////////////////////////

struct_item ::= STRUCT IDENTIFIER generic_params (struct_tuple_args? where_clause? ';' | where_clause? struct_decl_args)

struct_tuple_args ::= '(' <<comma_separated_list struct_tuple_field>> ')' { pin = 1}
struct_tuple_field ::= attrs_and_vis type

struct_decl_args ::= '{' <<comma_separated_list struct_decl_field>> '}' { pin = 1 }
struct_decl_field ::= attrs_and_vis IDENTIFIER ':' type { pin = 2 }


///////////////////////////////////////////////////////////////////////////////////////////////////
// Enum
///////////////////////////////////////////////////////////////////////////////////////////////////

enum_item ::= ENUM IDENTIFIER generic_params where_clause? '{' enum_variants? ','? '}'

private enum_variants ::= enum_variant (',' enum_variant)*

enum_variant ::= outer_attr* IDENTIFIER enum_args?

enum_args ::= enum_struct_args
            | enum_tuple_args
            | '=' any_expr

// unlike real structs, enum variants can't have `pub` visibility applied to fields
enum_tuple_args ::= '(' <<comma_separated_list enum_tuple_field>> ')' { pin = 1 }
enum_tuple_field ::= outer_attr* type

enum_struct_args ::= '{' <<comma_separated_list enum_struct_field>> '}' { pin = 1 }
enum_struct_field ::= outer_attr* IDENTIFIER ':' type { pin = 2}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Trait
///////////////////////////////////////////////////////////////////////////////////////////////////

trait_item ::= UNSAFE? TRAIT IDENTIFIER generic_params? type_param_bounds? where_clause? '{' trait_member* '}'

// TODO: use upper rules and inheritance here
private trait_member ::= trait_const_member
                       | trait_type_member
                       | trait_method_member

trait_const_member ::= outer_attr* CONST IDENTIFIER type_ascription? const_default? ';'

type_ascription ::= ':' type

private const_default ::= '=' any_expr

trait_type_member ::= outer_attr* TYPE_KW type_param ';'

trait_method_member ::= outer_attr* fn_header generic_params fn_decl_with_self_allow_anon_params where_clause? (';' | inner_attrs_and_block)

private fn_decl_with_self_allow_anon_params ::= fn_anon_params_with_self ret_type?
private fn_anon_params_with_self ::= '(' self_argument comma_anon_params? ')'
                                   | '(' anon_params? ')'

private comma_anon_params ::= ',' [ anon_params ','? ]

anon_params ::= anon_param (',' anon_param)*

anon_param ::= [ named_arg ':' ] type

private named_arg ::= &( IDENTIFIER
                       | '_'
                       | '&' (IDENTIFIER | '_')
                       | '&&' (IDENTIFIER | '_')
                       | MUT IDENTIFIER
                       ) pat


trait_ref ::= path_generic_args_without_colons


///////////////////////////////////////////////////////////////////////////////////////////////////
// Impl
///////////////////////////////////////////////////////////////////////////////////////////////////

impl_item ::= UNSAFE? IMPL generic_params type where_clause? '{' inner_attr* impl_member* '}'
            | UNSAFE? IMPL generic_params '!'? trait_ref FOR (type where_clause? '{' inner_attr* impl_member* '}' | '..' '{' '}') {
  pin(".*") = "'{'"
}

// TODO: unify with trait_member?
private impl_member ::= impl_method_member
                      | impl_const_member
                      | impl_macro_member
                      | impl_type_member

impl_method_member ::= attrs_and_vis fn_header generic_params fn_decl_with_self where_clause? inner_attrs_and_block

private fn_decl_with_self ::= fn_params_with_self ret_type?

private fn_params_with_self ::= '(' self_argument comma_params? ')'
                              | '(' params? ')'

self_argument ::= [ '&' LIFETIME? ] MUT? SELF type_ascription?

private comma_params ::= ',' [ params ','? ]

private impl_const_member ::= attrs_and_vis CONST static_decl ';'

private impl_type_member ::= attrs_and_vis TYPE_KW IDENTIFIER generic_params '=' type ';'


///////////////////////////////////////////////////////////////////////////////////////////////////
// Types
///////////////////////////////////////////////////////////////////////////////////////////////////

type ::= vec_type
       | ptr_type
       | ref_type
       | bare_fn_type
       | tuple_type
       | path_type
       | type_with_bounds_type
       | for_in_type
       | wildcard_type

vec_type ::= '[' type [';' any_expr] ']'

ptr_type ::= '*' [ MUT | CONST ] type

ref_type ::= ( '&' | '&&' ) [ LIFETIME? MUT? ] type

bare_fn_type ::= [ UNSAFE? extern_abi? ] FN fn_anon_params ret_type?

tuple_type ::= '(' [ <<comma_separated_list type>> ] ')'

path_type ::= !'<' path_generic_args_without_colons
            | &'<' type_qual_path

type_with_bounds_type ::= type '+' bound ('+' bound)*
bound ::= LIFETIME | trait_ref

for_in_type ::= FOR '<' lifetimes? '>' (bare_fn_type | trait_ref)

wildcard_type ::= '_'


type_item ::= TYPE_KW IDENTIFIER generic_params where_clause? '=' type ';'

type_qual_path ::= << qualified_path view_path_prefix >>

private types ::= type !'=' (',' type !'=')*

private fn_anon_params ::= '(' anon_param anon_params_allow_variadic_tail ')'
                         | '(' ')'

private anon_params_allow_variadic_tail ::= [ ',' ('...' | anon_param anon_params_allow_variadic_tail) ]




///////////////////////////////////////////////////////////////////////////////////////////////////
// Paths
///////////////////////////////////////////////////////////////////////////////////////////////////

path_part ::= ident_or_self_or_super [ '::' generic_args ]

//
// Paths (with `::` separating `generic_args` from actual name) used in expression contexts:
//
//    a::b::<T,U>::c
//

private path_generic_args_with_colons ::= path_generic_args_with_colons_part_leftish path_generic_args_with_colons_part*

left path_generic_args_with_colons_part ::= '::' path_generic_args_with_colons_part_inner {
  elementType = path_part
}

path_generic_args_with_colons_part_leftish ::= path_generic_args_with_colons_part_inner | &'::' {
  elementType = path_part
}

private path_generic_args_with_colons_part_inner ::= ident_or_self_or_super [ '::' generic_args ]


//
// TODO(kudinkin, matklad):
//
//    In rustc parser, self/super are treated as identifiers only if immediately followed by `::`
//    Thus, these are valid paths:
//
//      `foo :: bar ::baz`
//      `self:: super::foo ::baz`
//
//  and these are invalid ones
//
//      `self ::foo::bar`
//      `self::super ::foo`
//
// We parse all the above paths as valid.
//
private ident_or_self_or_super ::= IDENTIFIER | SUPER | SELF | CSELF


//
// Paths (w/o types and therefore `generic_args`, containing only identifiers, `self`, etc.):
//
//    a::b::c
//
private path_without_types ::= path_without_types_part_leftish path_without_types_part*

path_without_types_part_leftish ::= path_without_types_part_inner {
  elementType = path_part
}

left path_without_types_part ::= '::' path_without_types_part_inner {
  elementType = path_part
}

private path_without_types_part_inner ::= ident_or_self_or_super

//
// Paths (w/o `::` separating `generic_args` from actual name) used in type contexts:
//
//    a::b<T,U>::c<V,W>
//    a::b<T,U>::c(V) -> W
//    a::b<T,U>::c(V)
//

private path_generic_args_without_colons ::= path_generic_args_without_colons_part_leftish path_generic_args_without_colons_part*

left path_generic_args_without_colons_part ::= '::' path_generic_args_without_colons_part_inner {
  elementType = path_part
}

path_generic_args_without_colons_part_leftish ::= path_generic_args_without_colons_part_inner | &'::' {
  elementType = path_part
}

private path_generic_args_without_colons_part_inner ::= ident_or_self_or_super [ generic_args | '(' types? ')' ret_type? ]


//
// Qualified paths
//
//    <TYPE [as TRAIT_REF]> :: (path_without_types | path_generic_args_without_colons | path_generic_args_with_colons)
//
//    <T>::c<V,W>
//    <T as Foo>::c(V) -> W
//
private meta qualified_path ::= '<' type [ AS trait_ref ] '>' '::' << param >>


///////////////////////////////////////////////////////////////////////////////////////////////////
// Views
///////////////////////////////////////////////////////////////////////////////////////////////////

//
// Paths used in use items:
//
//    foo::bar::{self, foo}
//    {foo, bar}
//    ::foo::*
//    foo::bar as baz
//    foo::{}
//
view_path ::= [ view_path_prefix? '::' ] use_glob_list
            |   view_path_prefix '::' '*'
            |   view_path_prefix alias?

use_glob_list ::= '{' [ <<comma_separated_list use_glob>> ] '}'
use_glob ::= (IDENTIFIER | SELF) alias?

alias ::= AS IDENTIFIER

private view_path_prefix ::= view_path_part_leftish view_path_part*

view_path_part_leftish ::= '::'? (SELF | SUPER | IDENTIFIER) {
  elementType = path_part
}

left view_path_part ::= '::' (SUPER | IDENTIFIER) {
  elementType = path_part
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////////////////////////

//
// NOTA BENE
//
//  That's a synthetic production solely designated to produce
//  valid PSI hierarchy, to use the unrestricted version of expression check `unrestricted_expr`
//
expr ::=

restricted_expr ::= ret_expr
                  | assign_bin_expr
                  | block_expr
                  | cont_expr
                  | break_expr
                  | lambda_expr
                  | full_range_expr
                  | open_range_expr
                  | bool_or_bin_expr
                  | bool_and_bin_expr
                  | bit_or_bin_expr
                  | bit_xor_bin_expr
                  | bit_and_bin_expr
                  | comp_bin_expr
                  | rel_comp_bin_expr
                  | bit_shift_bin_expr
                  | add_bin_expr
                  | mul_bin_expr
                  | cast_expr
                  | unary_expr
                  | atom_expr {
  elementType = expr
}

// https://github.com/rust-lang/rfcs/blob/master/text/0092-struct-grammar.md
private no_struct_lit_expr  ::= << withoutStructLiterals restricted_expr >>
private any_expr            ::= << withStructLiterals restricted_expr >>


block_expr ::= while_expr
             | while_let_expr
             | if_expr
             | if_let_expr
             | for_expr
             | loop_expr
             | match_expr
             | (UNSAFE &'{')? block


private atom_expr ::= lit_expr
                    | macro_expr
                    | struct_expr
                    | qual_path_expr
                    | method_call_expr
                    | field_expr
                    | index_expr
                    | path_expr !'('
                    | call_expr
                    | array_expr
                    | unit_expr
                    | tuple_or_paren_expr


binary_expr ::= restricted_expr + {
    methods=[
        left="/expr[0]"
        right="/expr[1]"
    ]
}

assign_bin_expr ::= restricted_expr
                  ( GTGTEQ
                  | LTLTEQ
                  | '|='
                  | '^='
                  | '&='
                  | '='
                  | '+='
                  | '-='
                  | '*='
                  | '/='
                  | '%='
                  ) restricted_expr    { rightAssociative = true }

comp_bin_expr       ::= restricted_expr ('==' | '!=') restricted_expr
rel_comp_bin_expr   ::= restricted_expr ('<' !('<' | '=') | '>' !('>' | '=') | LTEQ | GTEQ) restricted_expr
bit_shift_bin_expr  ::= restricted_expr (LTLT | GTGT) restricted_expr
add_bin_expr        ::= restricted_expr ('+' | '-') restricted_expr
mul_bin_expr        ::= restricted_expr ('*' | '/' | '%') restricted_expr

bool_or_bin_expr    ::= restricted_expr '||' restricted_expr
bool_and_bin_expr   ::= restricted_expr '&&' restricted_expr
bit_or_bin_expr     ::= restricted_expr '|' restricted_expr
bit_xor_bin_expr    ::= restricted_expr '^' restricted_expr
bit_and_bin_expr    ::= restricted_expr '&' restricted_expr


cast_expr ::= restricted_expr AS type

unary_expr ::= ('-' | '*' | '!' | ('&' | '&&') MUT?) restricted_expr

lambda_expr ::= MOVE? ('||' | '|' [ <<comma_separated_list lambda_param>> ] '|') ret_type? any_expr
lambda_param ::= pat type_ascription?

struct_expr ::= << checkStructAllowed >> path_generic_args_with_colons struct_expr_body

struct_expr_body ::= '{'
                       [ <<comma_separated_list (IDENTIFIER ':' any_expr)>> ]
                       ('..'  any_expr)?
                     '}'

path_expr ::= path_generic_args_with_colons

qual_path_expr ::= << qualified_path path_generic_args_with_colons >>

while_expr ::= [ LIFETIME ':' ] WHILE no_struct_lit_expr block

loop_expr ::= [ LIFETIME ':' ] LOOP block
cont_expr ::= CONTINUE LIFETIME?

break_expr ::= BREAK LIFETIME?

scoped_for_decl ::= pat IN no_struct_lit_expr

for_expr ::= [ LIFETIME ':' ] FOR scoped_for_decl block { pin = "IN" }

match_expr ::= MATCH no_struct_lit_expr '{' match_arm* '}'

match_arm ::= outer_attr* match_pat '=>' (block_expr ','? | any_expr (',' | &'}'))
match_pat ::= pat ('|' pat)* (IF any_expr)?

if_expr ::= IF no_struct_lit_expr block else_tail?

private else_tail ::= ELSE (if_expr | if_let_expr | block )

fake scoped_let_expr ::= scoped_let_decl '=' no_struct_lit_expr block

scoped_let_decl ::= LET pat '=' no_struct_lit_expr

if_let_expr ::= IF scoped_let_decl block else_tail?

while_let_expr ::= WHILE scoped_let_decl block

ret_expr ::= RETURN restricted_expr?

unit_expr ::= '(' ')'

// It is possible to distinguish between paren_expr (any_expr) and a single element
// tuple_expr (any_expr,) only after almost all input has been consumed. That is, it's
// not LL(k) for any k. So let's use a custom rule to avoid exponential backtracking.
tuple_or_paren_expr ::= << tupleOrParenExpr any_expr tuple_expr_end paren_expr_end >>

// Used by `tupleOrParenExpr`
tuple_expr ::= '(' any_expr tuple_expr_end
private tuple_expr_end ::= ',' [ any_expr (',' any_expr)* ','? ] ')'

// Used by `tupleOrParenExpr`
paren_expr ::= '(' any_expr paren_expr_end
private paren_expr_end ::= ')'

array_expr ::= '[' array_elems? ']' { pin = 1 }

private array_elems ::= any_expr ';' any_expr
                      | expr_list


//private range_expr_group ::= open_range_expr
//                           | full_range_expr

full_range_expr ::= restricted_expr '..' (&<<checkBraceAllowed>> restricted_expr)?
open_range_expr ::=                 '..' (&<<checkBraceAllowed>> restricted_expr)?

range_expr ::= restricted_expr + {
    methods=[
        from="/expr[0]"
        to="/expr[1]"
    ]
}


index_expr ::= restricted_expr index_arg

private index_arg ::= '[' restricted_expr ']'

call_expr ::= restricted_expr arg_list

method_call_expr ::= restricted_expr '.' IDENTIFIER [ '::' generic_args ] arg_list { pin = 2 }

arg_list ::= '(' expr_list? ')' { pin = 1 }

private expr_list ::= <<comma_separated_list any_expr>>

field_expr ::= restricted_expr '.' (IDENTIFIER | INTEGER_LITERAL) { pin(".*") = 2 }

lit_expr ::= lit


///////////////////////////////////////////////////////////////////////////////////////////////////
// Macros
///////////////////////////////////////////////////////////////////////////////////////////////////

macro_invocation ::= IDENTIFIER '!'

macro_expr ::= build_in_macro | macro_invocation macro_arg

private build_in_macro ::= try_macro_invocation '(' any_expr ')'
                         | format_like_macro_invocation '(' format_macro_args ')'

try_macro_invocation ::= "try" '!' {
  elementType = macro_invocation
}

// https://doc.rust-lang.org/std/fmt/
format_like_macro_invocation ::= ( "format"
                                 | "format_args"
                                 | "write"
                                 | "writeln"
                                 | "print"
                                 | "println"
                                 // logging macros from the log crate
                                 | "debug"
                                 | "error"
                                 | "info"
                                 | "log"
                                 | "trace"
                                 | "warn" ) '!' {
  elementType = macro_invocation
}

format_macro_args ::= <<comma_separated_list format_macro_arg>>
private format_macro_arg ::= IDENTIFIER '=' any_expr | any_expr

pat_macro  ::= IDENTIFIER '!' macro_arg

macro_arg ::= '(' token_tree? ')'
            | '{' token_tree? '}'
            | '[' token_tree?  ']' { pin = 1 }

// This "parses" both macro definitions and macro usage
item_macro ::= macro_invocation IDENTIFIER?
             ( '(' token_tree? ')' ';'
             | '{' token_tree? '}'
             | '[' token_tree? ']' ';' )

impl_macro_member ::= macro_invocation IDENTIFIER?
             ( '(' token_tree? ')' ';'
             | '{' token_tree? '}'
             | '[' token_tree? ']' ';' )

token_tree ::= '(' token_tree* ')' token_tree*
             | '{' token_tree* '}' token_tree*
             | '[' token_tree* ']' token_tree*
             | << unpairedToken >> + token_tree*


///////////////////////////////////////////////////////////////////////////////////////////////////
// Literals
///////////////////////////////////////////////////////////////////////////////////////////////////

private lit ::= ( STRING_LITERAL
                | CHAR_LITERAL
                | BYTE_STRING_LITERAL
                | BYTE_LITERAL
                | RAW_STRING_LITERAL
                | RAW_BYTE_STRING_LITERAL
                | INTEGER_LITERAL
                | FLOAT_LITERAL
                | bool_lit )

private bool_lit ::= FALSE | TRUE


///////////////////////////////////////////////////////////////////////////////////////////////////
// Declarations
///////////////////////////////////////////////////////////////////////////////////////////////////

let_decl ::= LET pat [ ':' type ] [ '=' any_expr ] ';' { pin = "LET" }


///////////////////////////////////////////////////////////////////////////////////////////////////
// Statements
///////////////////////////////////////////////////////////////////////////////////////////////////

block ::= '{' stmt_* any_expr? '}' {
  pin(".*") = 1
}

inner_attrs_and_block ::= '{' inner_attr* stmt_* any_expr? '}' {
  elementType = block
  pin(".*") = 1
}


expr_stmt   ::= any_expr ';' | (block_expr !'.')
decl_stmt   ::= item | let_decl
empty_stmt  ::= ';'

// TODO(kudinkin):  That's a hack to overcome GK's bug
//                  producing parsing rules for `fake` productions

stmt ::=

private stmt_ ::= expr_stmt
                | decl_stmt
                | empty_stmt


///////////////////////////////////////////////////////////////////////////////////////////////////
// Utils
///////////////////////////////////////////////////////////////////////////////////////////////////

GTGTEQ ::= '>' '>' '='
GTGT   ::= '>' '>'
GTEQ   ::= '>' '='

LTLTEQ ::= '<' '<' '='
LTLT   ::= '<' '<'
LTEQ   ::= '<' '='

// Trailing commas are allowed
private meta comma_separated_list ::= <<param>> ( ',' <<param>> ) * ','?

private skip_until_eol_rec ::= !(<< skipUntilEOL >>)
